import{EtherscanProvider as e}from"@ethersproject/providers";import{CHAIN_ID_MAINNET as t,PRIVY_ETHERSCAN_ID as r}from"../../constants.mjs";import{i as a}from"../../ethers-Cz-frLvN.mjs";import"@ethersproject/bignumber";async function n({accessToken:e,entropyId:r,entropyIdVerifier:a,transactingWallet:n,walletProxy:o,transactionRequest:s,provider:i,requesterAppId:c}){!function(e){for(let t of["gasLimit","gasPrice","value","maxPriorityFeePerGas","maxFeePerGas"]){let r=e[t];if(void 0!==r&&!function(e){let t="number"==typeof e,r="bigint"==typeof e,a="string"==typeof e&&/^-?0x[a-f0-9]+$/i.test(e);return t||r||a}(r))throw Error(`Transaction request property '${t}' must be a valid number, bigint, or hex string representing a quantity`)}if("number"!=typeof e.chainId)throw Error("Transaction request property 'chainId' must be a number")}(s=Object.assign({chainId:t},s));let u=(await o.rpc({entropyId:r,entropyIdVerifier:a,hdWalletIndex:n.walletIndex??0,chainType:"ethereum",accessToken:e,requesterAppId:c,request:{method:"eth_signTransaction",params:[s]}})).response.data;return await i.sendTransaction(u)}async function o(e,t,r,n){let o=await n.getBalance(e),s=t.value||0,i=!o.sub(a(s)).sub(r).isNegative();return{balance:o,hasSufficientFunds:i}}async function s(){let a=new e(t,r);return await a.getEtherPrice()}function i(e){return{to:e.to,from:e.from,contractAddress:e.contractAddress,transactionIndex:e.transactionIndex,root:e.root,logsBloom:e.logsBloom,blockHash:e.blockHash,transactionHash:e.transactionHash,logs:e.logs,blockNumber:e.blockNumber,confirmations:e.confirmations,byzantium:e.byzantium,type:e.type,status:e.status,gasUsed:e.gasUsed.toHexString(),cumulativeGasUsed:e.cumulativeGasUsed.toHexString(),effectiveGasPrice:e.effectiveGasPrice?e.effectiveGasPrice.toHexString():void 0}}export{i as formatReceipt,o as getAndCheckBalance,s as getEtherPrice,n as sendTransaction};
