import{jsx as e,jsxs as t}from"react/jsx-runtime";import{getAddress as a}from"@ethersproject/address";import{Web3Provider as r}from"@ethersproject/providers";import{createStore as n}from"mipd";import{useState as i,useRef as o,useEffect as s,useMemo as l}from"react";import{isAndroid as c}from"react-device-detect";import{CustomJwtAccountFlow as d}from"./auth-flows/custom-jwt-account.mjs";import{UpdateEmailFlow as u,EmailFlow as h}from"./auth-flows/email.mjs";import{FarcasterFlow as p}from"./auth-flows/farcaster.mjs";import{GuestFlow as w}from"./auth-flows/guest.mjs";import{PasskeyFlow as m}from"./auth-flows/passkey.mjs";import{SiweFlow as y}from"./auth-flows/siwe.mjs";import{SiwsFlow as f}from"./auth-flows/siws.mjs";import{UpdateSmsFlow as g,SmsFlow as E}from"./auth-flows/sms.mjs";import{TelegramAuthFlow as _,detectCompletingTelegramFlow as A}from"./auth-flows/telegram.mjs";import{v4 as v}from"uuid";import{AccessToken as T}from"./accessToken.mjs";import{getEntropyDetailsFromAccount as C,convertUserResponseToUser as I,getPrivySolanaWallet as k,getPrivyPrimaryWallet as W,getEntropyDetailsFromUser as N,getPrivyEthereumWallet as b,getPrivyEthereumHDWallets as U,getImportedPrivyEthereumWallet as O,shouldProceedtoEmbeddedWalletCreationFlow as S,getLatestPrivyEthereumWallet as R,getEthereumSigningAndRootWallet as P,getSolanaSigningAndRootWallet as L}from"./client/user.mjs";import M from"eventemitter3";import{CONNECTORS_STATE_KEY as D,CONNECTIONS_HISTORY_KEY as F,DEFAULT_PRIVY_API_URL as x,DEFAULT_API_TIMEOUT_MS as j,CLIENT_ANALYTICS_ID_KEY as B,CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as V,PRIVY_ACCESS_TOKEN_STORAGE_KEY as H,getGuestCredentialStorageKey as K,HEADLESS_OAUTH_KEY as G,OAUTH_DISABLE_SIGNUP_KEY as z,STATE_CODE_KEY as q,WALLET_PROXY_TIMEOUT as $,FORKED_TOKEN_STORAGE_KEY as Y}from"./constants.mjs";import X,{isLocalStorageAccessible as Q}from"./storage.mjs";import{getJsonRpcProvider as J,generateTypedDataWithDomainType as Z,toHex as ee,detectInjectedConnectors as te,formatChainIdToCAIP2 as ae}from"./utils/index.mjs";import{CoinbaseWalletConnector as re}from"./connectors/coinbase.mjs";import{EmbeddedWalletConnector as ne}from"./connectors/embedded.mjs";import{isSupportedEthereumRpcMethod as ie}from"./embedded-wallets/rpc/types.mjs";import{Captcha as oe}from"./components/Captcha.mjs";import{LoginModal as se}from"./components/LoginModal.mjs";import{TelegramLoginButton as le}from"./components/TelegramLoginButton.mjs";import{PrivyAppConfigProvider as ce,useAppConfig as de,useIsServerConfigLoaded as ue}from"./configuration/context.mjs";import{areWalletArraysEqual as he}from"./connectors/areWalletArraysEqual.mjs";import{PrivyProviderRpcError as pe,ProviderRpcError as we}from"./connectors/errors.mjs";import{isPhantomInstalled as me}from"./connectors/is-wallet-installed.mjs";import{isBaseConnectedEthereumWallet as ye}from"./connectors/isBaseConnectedEthereumWallet.mjs";import{PrivyProxyProvider as fe,AsExternalProvider as ge,AsAbstractProvider as Ee}from"./connectors/privyProxyProvider.mjs";import{isSolanaWalletConnector as _e,isBaseConnectedSolanaWallet as Ae}from"./connectors/solana/index.mjs";import{WalletConnectV2WalletConnector as ve}from"./connectors/walletconnect-v2.mjs";import{EmbeddedWalletIframe as Te}from"./embedded-wallets/EmbeddedWalletIframe.mjs";import{isWalletDelegated as Ce,getDelegatedWalletsData as Ie,getRootWalletDataForDelegation as ke,getDelegatedWalletsForUser as We}from"./embedded-wallets/delegated-actions.mjs";import{errorIndicatesRecoveryIsNeeded as Ne}from"./embedded-wallets/errors.mjs";import{formatReceipt as be,getAndCheckBalance as Ue,sendTransaction as Oe}from"./embedded-wallets/rpc/index.mjs";import{PrivyClientError as Se,formatApiError as Re,formatPrivyError as Pe,PrivyErrorCode as Le,PrivyNotReadyError as Me,PrivyConnectorError as De,PrivyError as Fe}from"./errors.mjs";import{signSolanaTransaction as xe,sendSolanaTransaction as je}from"./embedded-wallets/solana/transaction.mjs";import{extractChainIdFromCAIP2 as Be}from"./lib/caip2.mjs";import{USE_BROADCAST_CHANNEL_EVENT_TYPE as Ve,isPrivyTheOAuthProvider as He,CROSS_APP_BROADCAST_CHANNEL_NAME as Ke}from"./lib/cross-app/index.mjs";import{getCrossAppAuthorizationUrl as Ge,authenticateCrossAppAccount as ze,getProviderAppMetadata as qe}from"./lib/cross-app/authFlow.mjs";import{popupCrossAppAuthFlow as $e}from"./lib/cross-app/popupCrossAppAuthFlow.mjs";import{sendCrossAppRequest as Ye}from"./lib/cross-app/sendCrossAppRequest.mjs";import{getRecoveryAuthorizationUrl as Xe,authenticateRecovery as Qe,embeddedWalletRecoveryScreen as Je,toEmbeddedWalletSetRecoveryScreen as Ze}from"./lib/embeddedWalletRecovery.mjs";import{FUNDING_SCREENS as et,fundingScreenMethodMap as tt}from"./lib/funding/index.mjs";import{isFundingEnabled as at}from"./lib/funding/isFundingEnabled.mjs";import rt from"./lib/isEmbeddedWebview.mjs";import{triggerPopup as nt}from"./lib/popup/triggerPopup.mjs";import{popupOAuthFlow as it}from"./lib/popupOAuthFlow.mjs";import{prepareSiweMessageWithNonce as ot}from"./lib/siwe.mjs";import{decodeSolanaTransaction as st,createSolanaTransactionReceipt as lt}from"./lib/solana/transaction.mjs";import{toDisplayFromAccountType as ct}from"./lib/toDisplayFromAccountType.mjs";import{transformResponseToSnakeCase as dt}from"./passkeys/transformResponseToSnakeCase.mjs";import{PrivyPluginProvider as ut,usePlugins as ht}from"./plugins/context/PrivyPluginContext.mjs";import{SOLANA_FUNDING_PLUGIN_ID as pt}from"./plugins/solana-funding/id.mjs";import{RecentlyUsedAccountProvider as wt}from"./recent-login/context.mjs";import{ModalScreen as mt}from"./screens/index.mjs";import{Hide as yt}from"./screens/LandingScreen/styles.mjs";import{GlobalStyle as ft}from"./styles.mjs";import{notImplemented as gt}from"./hooks/index.mjs";import{CaptchaProvider as Et}from"./hooks/captcha-context.mjs";import{privyEventsDefault as _t,emitPrivyEvent as At,PrivyEventsContext as vt}from"./hooks/events-context.mjs";import{InternalPrivyContext as Tt}from"./hooks/internal-context.mjs";import{ModalProvider as Ct}from"./hooks/modal-context.mjs";import{PrivyContext as It}from"./hooks/privy-context.mjs";import{UseWalletsContext as kt}from"./hooks/useWallets.mjs";import{prepareSolanaFundingModalData as Wt,prepareFundingModalData as Nt}from"./lib/funding/prepareFundingModalData.mjs";import{detectCompletingOAuthFlow as bt}from"./auth-flows/oauth/detectCompletingOAuthFlow.mjs";import{g as Ut,o as Ot}from"./index-B3QfI7v9.mjs";import{n as St}from"./errors-9ucGZPEs.mjs";import{OAuthFlow as Rt}from"./auth-flows/oauth/OAuthFlow.mjs";import{getRpcTimeout as Pt}from"./connectors/getRpcTimeout.mjs";import{EmbeddedProviderError as Lt}from"./connectors/providerTypes.mjs";import{isEthereumWalletConnector as Mt}from"./connectors/ethereum/index.mjs";import{LegacyInjectedWalletConnector as Dt,Injected6963WalletConnector as Ft}from"./connectors/injected.mjs";import{MetamaskWalletConnector as xt}from"./connectors/metamask.mjs";import{PhantomEthereumNullWalletConnector as jt}from"./connectors/phantom.mjs";import{PhantomSolanaNullWalletConnector as Bt}from"./connectors/phantom-solana.mjs";import{Http as Vt}from"./http.mjs";import{getPaymasterContext as Ht}from"./lib/smart-wallet-helpers.mjs";import{transformOptionsToCamelCase as Kt}from"./passkeys/transformOptionsToCamelCase.mjs";import{mfaPasswordlessSmsInitPath as Gt,mfaPasskeyInitPath as zt,acceptTermsPath as qt,unlinkEmailPath as $t,unlinkPhonePath as Yt,unlinkWalletPath as Xt,siwsUnlinkWalletPath as Qt,unlinkOAuthPath as Jt,unlinkFarcasterPath as Zt,telegramAccountUnlinkPath as ea,unlinkPasskeyPath as ta,delegatedActionsRevokePath as aa,analyticsEventsPath as ra,moonpayPluginOnRampPath as na,coinbaseOnRampInitPath as ia,coinbaseOnRampStatusPath as oa,siweInitPath as sa,siweAuthenticatePath as la,siweLinkPath as ca,smartWalletLinkPath as da,siwsInitPath as ua,siwsAuthenticatePath as ha,transferOAuthPath as pa,telegramAccountTransferPath as wa,transferFarcasterPath as ma,transferWalletPath as ya,transferPhonePath as fa,transferEmailPath as ga,siwsLinkPath as Ea}from"./paths.mjs";import{AccessTokenTypes as _a,Session as Aa}from"./session.mjs";class va extends M{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Lt(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await xa()||!this.address)throw new Lt("Disconnected",4900);return(await Va(t,void 0,void 0,this.address)).hash}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new Lt(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new Lt(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.provider=J(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],a=e.params[1];return await ja(t,void 0,a)}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],a="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1];return await Ba(Z(a),void 0,t)}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:ee(this.chainId)};try{return await this.provider.send("eth_estimateGas",[t])}catch(e){console.warn(`Gas estimation failed with error: ${e}. Retrying gas estimation by omitting the 'from' address`);try{return delete t.from,await this.provider.send("eth_estimateGas",[t])}catch(t){throw console.warn(`Gas estimation failed with error: ${t} when omitting the 'from' address`),e}}}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return ee(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!ie(e.method))return this.provider.send(e.method,e.params);{let t=await xa();if(await Ha(),!t||!this.address)throw new Lt("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new Lt("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:a,entropyIdVerifier:r,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=a,this.entropyIdVerifier=r,this.chainId=s,this.rpcConfig=n,this.chains=i,this.provider=J(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=Pt(n,"privy"),this.appId=o,this.walletIndex=l}}class Ta extends M{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let a=`${t.address}${t.walletClientType}${t.connectorType}`;return!e.has(a)&&(e.add(a),!0)})),a=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return a>=0&&t.unshift(t.splice(a,1)[0]),t}async initialize(){if(this.initialized)return;X.get(D)&&(X.getKeys().forEach((e=>{e.startsWith("walletconnect")&&X.del(e)})),X.del(D));let e=te({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:a})=>{this.createEthereumWalletConnector("injected",e,{eip6963InjectedProvider:t,legacyInjectedProvider:a})}))}));this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector("coinbase_wallet","coinbase_wallet"),!me()&&this.walletList.includes("phantom")&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&this.createEthereumWalletConnector("phantom","phantom"),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&this.addWalletConnector(new Bt)),this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector("wallet_connect_v2","unknown"),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await e,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(Mt).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(Mt).find((a=>a.connectorType===e&&a.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(_e).find((a=>a.connectorType===e&&a.walletClientType===t))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:a,defaultChain:r,appId:n}){for(let i of a){let a=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(a&&Mt(a))a.proxyProvider.walletProxy=e;else{let{entropyId:a,entropyIdVerifier:o}=C(t),s=new ne({provider:new va({walletProxy:e,address:i.address,entropyId:a,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:r.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,a,r){let n=this.findWalletConnector("embedded_imported","privy");if(n&&Mt(n))n.proxyProvider.walletProxy=e;else{let n=new ne({provider:new va({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:a.id}),chains:this.chains,walletIndex:0,defaultChain:a,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=Ca(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=Ca(),this.emit("walletsUpdated")}}async createEthereumWalletConnector(e,t,a){let r=this.findWalletConnector(e,t);if(r&&Mt(r))return r instanceof ve&&r.resetConnection(t),r;let n=(()=>"injected"!==e?"coinbase_wallet"===e?new re(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"phantom"===e?new jt(this.defaultChain):new ve(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):"metamask"===t&&a?.eip6963InjectedProvider?new xt(this.chains,this.defaultChain,this.rpcConfig,a?.eip6963InjectedProvider,"metamask"):"metamask"===t&&a?.legacyInjectedProvider?new Dt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider,"metamask"):"phantom"===t&&a?.legacyInjectedProvider?new Dt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider,"phantom"):a?.legacyInjectedProvider&&"unknown_browser_extension"===t?new Dt(this.chains,this.defaultChain,this.rpcConfig,a?.legacyInjectedProvider):a?.eip6963InjectedProvider?new Ft(this.chains,this.defaultChain,this.rpcConfig,a?.eip6963InjectedProvider,t):void 0)();return n&&this.addWalletConnector(n),n||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt})));X.put(F,e)}async activeWalletSign(e){let t=this.wallets,a=t.length>0?t[0]:null;return a&&ye(a)?a.sign(e):null}setActiveWallet(e){this.activeWallet=a(e),this.emit("walletsUpdated")}constructor(e,t,a,r,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new fe},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=a,this.chains=r,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=Ca()}}const Ca=()=>{let e=X.get(F);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let Ia;var ka=0,Wa="__private_"+ka+++"__getOrGenerateClientAnalyticsId";class Na{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:a,defaultChain:r,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new Ta(this.appId,e,t,a,r,n,i,o,s,l,void 0,c))}generateApi(){let e=new Vt({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Se("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Se("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(Gt,{action:"verify"})}catch(e){throw Re(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(zt,{});return Kt(e.options)}catch(e){throw Re(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(qt,{});return I(e)}catch(e){throw Pe(e)}}async unlinkEmail(e){try{let t=await this.api.post($t,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async unlinkPhone(e){try{let t=await this.api.post(Yt,{phoneNumber:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(Xt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(Qt,{address:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async unlinkOAuth(e,t){try{let a=await this.api.post(Jt,{provider:e,subject:t});return await this.getAuthenticatedUser()??I(a)}catch(e){throw Pe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(Zt,{fid:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(ea,{telegram_user_id:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async unlinkPasskey(e){try{let t=await this.api.post(ta,{credential_id:e});return await this.getAuthenticatedUser()??I(t)}catch(e){throw Pe(e)}}async revokeDelegatedWallet(){try{await this.api.post(aa,{})}catch(e){throw Pe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:a,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(ra,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:a?a.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(na,e)}catch(e){throw Pe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(ia,e)}catch(e){throw Pe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${oa}?partnerUserId=${e}`)}catch(e){throw Pe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(_a.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(_a.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?T.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let a=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return a.enabled?{enabled:a.enabled,smartWalletType:a.smart_wallet_type,configuredNetworks:a.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:Ht(e.paymaster_url,e.paymaster_context)})))}:{enabled:a.enabled}}catch(e){throw Pe(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let a=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),r=a.telegram_auth_config?{botId:a.telegram_auth_config.bot_id,botName:a.telegram_auth_config.bot_name,linkEnabled:a.telegram_auth_config.link_enabled,seamlessAuthEnabled:a.telegram_auth_config.seamless_auth_enabled}:void 0,n=a.funding_config?{methods:a.funding_config.methods,options:a.funding_config.options,defaultRecommendedAmount:a.funding_config.default_recommended_amount,defaultRecommendedCurrency:a.funding_config.default_recommended_currency,promptFundingOnWalletCreation:a.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:a.funding_config.cross_chain_bridging_enabled}:void 0;return{id:a.id,name:a.name,verificationKey:a.verification_key,logoUrl:a.logo_url||void 0,accentColor:a.accent_color||void 0,showWalletLoginFirst:a.show_wallet_login_first,allowlistConfig:{errorTitle:a.allowlist_config.error_title,errorDetail:a.allowlist_config.error_detail,errorCtaText:a.allowlist_config.cta_text,errorCtaLink:a.allowlist_config.cta_link},walletAuth:a.wallet_auth,solanaWalletAuth:a.solana_wallet_auth,emailAuth:a.email_auth,smsAuth:a.sms_auth,googleOAuth:a.google_oauth,twitterOAuth:a.twitter_oauth,discordOAuth:a.discord_oauth,githubOAuth:a.github_oauth,spotifyOAuth:a.spotify_oauth,instagramOAuth:a.instagram_oauth,tiktokOAuth:a.tiktok_oauth,linkedinOAuth:a.linkedin_oauth,appleOAuth:a.apple_oauth,farcasterAuth:a.farcaster_auth,passkeyAuth:a.passkey_auth,telegramAuth:a.telegram_auth,disablePlusEmails:a.disable_plus_emails,termsAndConditionsUrl:a.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:a.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:a.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:a.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:a.privacy_policy_url,requireUsersAcceptTerms:a.require_users_accept_terms,customApiUrl:a.custom_api_url,walletConnectCloudProjectId:a.wallet_connect_cloud_project_id,fiatOnRampEnabled:a.fiat_on_ramp_enabled,captchaEnabled:a.captcha_enabled,captchaSiteKey:a.captcha_site_key,createdAt:new Date(1e3*a.created_at),updatedAt:new Date(1e3*a.updated_at),mfaMethods:a.mfa_methods,enforceWalletUis:a.enforce_wallet_uis,legacyWalletUiConfig:a.legacy_wallet_ui_config,telegramAuthConfiguration:r,fundingConfig:n}}catch(e){throw Pe(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(sa,{address:e,token:t})).nonce}catch(e){throw Pe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n,mode:i}){return await this.api.post(la,{message:e,signature:t,chainId:a,walletClientType:r,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}){return await this.api.post(ca,{message:e,signature:t,chainId:a,walletClientType:r,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:a}){try{let r=await this.api.post(da,{message:e,signature:t,smart_wallet_type:a});return I(r)}catch(e){throw Pe(e)}}async linkWithSiwe({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n});return I(i)}catch(e){throw Pe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(ua,{address:e,token:t})).nonce}catch(e){throw Pe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r,mode:n}){return await this.api.post(ha,{message:e,signature:t,walletClientType:a,connectorType:r,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o}){try{let s,l;switch(a){case"email":s=ga,l={nonce:e,email:t};break;case"sms":s=fa,l={nonce:e,phoneNumber:t};break;case"siwe":if(s=ya,!r)throw Error("Wallet parameters must be defined");l={nonce:e,address:t,...r};break;case"farcaster":s=ma,l={nonce:e,farcaster_id:t,farcaster_embedded_address:i};break;case"telegram":s=wa,l={nonce:e,telegram_auth_result:n};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:s=pa,l={nonce:e,userInfo:o}}let c=await this.api.post(s,l);return await this.getAuthenticatedUser()??I(c)}catch(e){throw Pe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r}){return await this.api.post(Ea,{message:e,signature:t,walletClientType:a,connectorType:r})}async linkWithSiws({message:e,signature:t,walletClientType:a,connectorType:r}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:a,connectorType:r});return I(n)}catch(e){throw Pe(e)}}constructor({apiUrl:e=x,appId:t,appClientId:a,timeout:r=j}){Object.defineProperty(this,Wa,{value:ba}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==x&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=a,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Wa)[Wa](),Ia||(Ia=new Aa),this.session=Ia,this.api=this.generateApi(),this.session.client=this}}function ba(){if("undefined"==typeof window)return null;try{let e=X.get(B);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=v();try{return X.put(B,e),e}catch(t){return e}}class Ua{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await Ga({message:e.params.message})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await xa())throw Error("User must be authenticated to use embedded Solana wallet");if(!await Ka())throw new Se("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let Oa,Sa,Ra,Pa,La,Ma,Da;function Fa(){return Oa?Oa.getCustomerAccessToken():Promise.resolve(X.get(V)||null)}async function xa(){return Oa?Oa.getAccessToken():Promise.resolve(X.get(H)||X.get(V)||null)}const ja=(e,t,a)=>Sa(e,t,a),Ba=(e,t,a)=>Ra(e,t,a),Va=(e,t,a,r)=>Pa(e,t,a,r),Ha=()=>La(),Ka=()=>Ma(),Ga=({message:e})=>Da({message:e});const za=({config:t,...a})=>{var r;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&"https:"!==window.location.protocol)throw new Se("Embedded wallet is only available over HTTPS");if("string"!=typeof(r=a.appId)||25!==r.length)throw new Se("Cannot initialize the Privy provider with an invalid Privy app ID");Oa||(Oa=new Na({appId:a.appId,appClientId:a.clientId,apiUrl:a.apiUrl}));let n=Object.assign({},t);return void 0!==a.createPrivyWalletOnLogin&&void 0===n.embeddedWallets?.createOnLogin&&(n.embeddedWallets||(n.embeddedWallets={}),n.embeddedWallets.createOnLogin=a.createPrivyWalletOnLogin?"users-without-wallets":"off"),void 0!==a.createPrivyWalletOnLogin&&t?.embeddedWallets?.createOnLogin&&console.warn("Both `createPrivyWalletOnLogin` and `config.embeddedWallets.createOnLogin` are set. `createPrivyWalletOnLogin` is deprecated and should be removed."),/*#__PURE__*/e(ce,{client:Oa,clientConfig:n,legacyCreateEmbeddedWalletFlag:a.createPrivyWalletOnLogin,children:/*#__PURE__*/e(ut,{children:/*#__PURE__*/e(qa,{...a,client:Oa})})})};let qa=v=>{let T=v.client,I=ht(),[M,D]=i(!1),[F,j]=i(!1),[V,H]=i(!1),[te,re]=i(null),[ne,ie]=i([]),[ce,_e]=i([]),[Re,Pe]=i(null),ut=o(ne),[Pt,Lt]=i(!1),[Mt,Dt]=i(null),[Ft,xt]=i(!1),[jt,Bt]=i({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:gt}),[Vt,Ht]=i({status:"initial"}),[Kt,Gt]=i({status:"initial"}),[zt,qt]=i({status:"initial"}),[$t,Yt]=i({status:"initial"}),[Xt,Qt]=i({status:"initial"}),[Jt,Zt]=i(null),ea=de(),ta=ue(),[aa,ra]=i(!0),[na,ia]=i({}),[oa,sa]=i(null),[la,ca]=i(null),[da,ua]=i(!1),[ha,pa]=i(!1),[wa,ma]=i(ea.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),ya=o(null),fa=o(null),ga=o(_t),[Ea,_a]=i(!1);T.onStoreCustomerAccessToken=e=>{e&&At(ga,"accessToken","onAccessTokenGranted",e)},T.onDeleteCustomerAccessToken=()=>{re(null),H(!1),At(ga,"accessToken","onAccessTokenRemoved")};let Aa=o(null),va=o(null),Ta=o(!1),Ca=({showWalletUIs:e,typedData:t})=>Ta.current?Ta.current:void 0!==e?!e:void 0!==ea.embeddedWallets.showWalletUIs?!ea.embeddedWallets.showWalletUIs:t?ea.embeddedWallets.noPromptOnSignature||(ea.legacyWalletUiConfig??!1):!!ea.embeddedWallets.noPromptOnSignature,Ia=e=>{Dt(e),setTimeout((()=>{D(!0)}),15),T.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},ka=e=>{"off"!==ea.embeddedWallets.createOnLogin&&ra(!0),Ia(e)};s((()=>{let e=k(te);if(!e||!Jt)return void Pe(null);let t={type:"solana",imported:!1,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new Se("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new Se("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Ua(Jt,e.address),async signMessage(e){let t=await xa(),a=W(te);if(!t||!Jt||!a)throw new Se("Must have valid access token and Privy wallet to send transaction",Le.MUST_BE_AUTHENTICATED);if(!await sr.recoverPrimaryWallet().catch((()=>!1)))throw new Se("Wallet couldn't be connected",Le.UNKNOWN_CONNECT_WALLET_ERROR);let{entropyId:r,entropyIdVerifier:n}=C(a),{response:i}=await Jt.rpc({accessToken:t,entropyId:r,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:this.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(e).toString("base64")}}});return Buffer.from(i.data.signature,"base64")},async sendTransaction(e,t,a){let{signature:r}=await er({transaction:e,connection:t,transactionOptions:a,wallet:this});return r},async signTransaction(e){let t=await xa();if(!t||!Jt)throw new Se("Must have valid access token and Privy wallet to send transaction",Le.MUST_BE_AUTHENTICATED);if(!await sr.recoverPrimaryWallet().catch((()=>!1)))throw new Se("Wallet couldn't be connected",Le.UNKNOWN_CONNECT_WALLET_ERROR);let{entropyId:a,entropyIdVerifier:r}=N(te);return await xe({tx:e,accessToken:t,walletProxy:Jt,entropyId:a,entropyIdVerifier:r,transactingWalletAddress:this.address,transactingWalletIndex:this.walletIndex??0}),e},loginOrLink:async()=>{throw new Se("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{Pe(null)},isConnected:async()=>!0};Pe(t)}),[Jt,te]),s((()=>{if(!te)return void T.connectors?.removeEmbeddedWalletConnectors();let e=b(te),t=U(te),a=O(te);e&&t.length||T.connectors?.removeEmbeddedWalletConnectors(),a||T.connectors?.removeImportedWalletConnector(),T.connectors?Jt?(e&&T.connectors.addEmbeddedWalletConnectors({walletProxy:Jt,rootWallet:e,embeddedWallets:t,defaultChain:ea.defaultChain,appId:v.appId}),a&&T.connectors.addImportedWalletConnector(Jt,a.address,ea.defaultChain,v.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[Jt,te]),s((()=>{Jt&&la?.(Jt)}),[Jt]);let Wa=o();s((()=>{(async()=>{if(!ea.customAuth?.enabled)return void ma({status:"not-enabled"});ra(!0);let{getCustomAccessToken:e,isLoading:t}=ea.customAuth;if(F&&!t&&"loading"!==wa.status){ma({status:"loading"});try{let t=await e();if(t===Wa.current)return void ma({status:"done"});if(!t&&V)return Wa.current=t,await or.logout(),ma({status:"done"}),void At(ga,"customAuth","onUnauthenticated");if(!t)return Wa.current=t,void ma({status:"done"});T.startAuthFlow(new d(t));let{user:a,isNewUser:r}=await T.authenticate();if(!a)return await or.logout(),ma({status:"error",error:new Se("Failed to sync with custom auth provider")}),void At(ga,"customAuth","onUnauthenticated");void 0!==r&&At(ga,"login","onComplete",a,r,!1,"custom",null),Wa.current=t,At(ga,"customAuth","onAuthenticated",{user:a}),ma({status:"done"}),re(a||null),Lt(r||!1),H(!0),pa(!0)}catch(e){if(console.warn(e),await or.logout(),At(ga,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void ma({status:"initial"});At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),ma({status:"error",error:e})}}})()}),["initial"===wa.status,ea.customAuth?.enabled,ea.customAuth?.getCustomAccessToken,ea.customAuth?.isLoading,F,V]),s((()=>{ha&&Jt&&te&&S(te,ea.embeddedWallets.createOnLogin)&&(pa(!1),Ya(te,$).catch(console.error))}),[ha&&Jt&&te]),s((()=>{if(ea.externalWallets.solana.connectors)return ea.externalWallets.solana.connectors.onMount(),()=>ea.externalWallets.solana.connectors?.onUnmount()}),[ea.externalWallets.solana.connectors]),s((()=>{!F&&ta&&async function(){let e,t=Na(),a=ba();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;X.put(Y,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let r=n();T.initializeConnectorManager({walletConnectCloudProjectId:ea.walletConnectCloudProjectId,rpcConfig:ea.rpcConfig,chains:ea.chains,defaultChain:ea.defaultChain,store:r,walletList:ea.appearance.walletList,shouldEnforceDefaultChainOnConnect:ea.shouldEnforceDefaultChainOnConnect,externalWalletConfig:ea.externalWallets,appName:ea.name??"Privy",walletChainType:ea.appearance.walletChainType}),T.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=T.connectors.walletConnectors.length,a=T.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);a===t?_a(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:a,expected:t}),_a(!0)}),1500)})),T.connectors?.initialize().then((()=>{Ha()}));let i=await T.getAuthenticatedUser(),o=!!i;ea.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await T.logout(),sr.setReadyToTrue(!0),At(ga,"logout","onSuccess")):(ea.customAuth?.enabled||(H(!!i),i&&At(ga,"login","onComplete",i,!1,!0,null,null),re(i)),t?va.current=o?"link":"login":a&&!o?(va.current="login",ia({telegramAuthModalData:{seamlessAuth:!0}}),ka(mt.TELEGRAM_AUTH_SCREEN)):sr.setReadyToTrue(!!i))}()}),[T,oa,F,ta]),s((()=>{if(F){if(!te||!te.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void ua(!0);ua(!!ne.find((e=>"privy"===e.walletClientType)))}}),[F,te,ne]);let Na=()=>{let e=bt();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&He(e.provider)&&!e.popupFlow&&(new BroadcastChannel(Ke).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(T.startAuthFlow(new Rt(e)),ka(mt.AWAITING_OAUTH_SCREEN),!0))},ba=()=>{let e=A();if(!e||!ea.loginMethods.telegram||!ea.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new _;return T.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Fa=async(e,t,a,r)=>{ja(await(T.connectors?.createEthereumWalletConnector(e,t))||null,t,a,r)};async function ja(e,t,a,r){if(!e)return Bt({status:"disconnected",connectedWallet:null,connectError:new De("Unable to connect to wallet."),connector:null,connectRetry:gt}),r?.(null,a);Bt({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:gt}),e instanceof ve&&t&&await e.resetConnection(t),Bt({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>ja(e,t,a,r)});try{let t=await e.connect({showPrompt:!0});if((!t||ye(t))&&ea.shouldEnforceDefaultChainOnConnect&&!ea.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Bt((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:gt})));try{await(t?.switchChain(ea.defaultChain.id)),t&&(t.chainId=ae(ee(ea.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${ea.defaultChain.id}`)}}return Bt((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:gt}))),t&&At(ga,"connectWallet","onSuccess",(e.chainType,t)),r?.(t,a)}catch(e){return e instanceof Fe?(console.warn(e.cause?e.cause:e.message),At(ga,"connectWallet","onError",e.privyErrorCode||Le.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),At(ga,"connectWallet","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR)),Bt((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),r?.(null,a)}}let Ba=async(e,t,a)=>{if(null===e||!ye(e))return;let r=new y(e,T,t,a);T.startAuthFlow(r)},Va=async(e,t)=>{if(null===e||!Ae(e))return;let a=new f(e,T,t);T.startAuthFlow(a)},Ha=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),a=e.get("privy_wallet_client");if(!t||!a)return;if("phantom"!==a||me()||ka(mt.LOGIN_FAILED_SCREEN),!T.connectors)throw new Se("Connector not initialized");Ia(mt.AWAITING_CONNECTION);let r=new URL(window.location.href);r.searchParams.delete("privy_connector"),r.searchParams.delete("privy_wallet_client"),window.history.pushState({},"",r),Fa(t,a,void 0,Ba)};s((()=>{F&&V&&null===te&&T.getAuthenticatedUser().then(re)}),[F,V,te,T]);let Ka=e=>{if(!V)throw At(ga,"linkAccount","onError",Le.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Se("User must be authenticated before linking an account.")},Ga=()=>{Ka("siwe"),Aa.current="siwe",va.current="link",Ia(mt.LINK_WALLET_SCREEN)},za=e=>{if(!V||!te)return!1;if("privy"===e.walletClientType)return!0;for(let t of te.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},qa=async e=>{let t;if(!T.connectors)throw new Se("Connector not initialized");t="ethereum"===e.type?T.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:T.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,Bt((a=>({...a,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:gt}))),ea.captchaEnabled&&!V?(ia({captchaModalData:{callback:t=>ye(e)?Ba(e,t):Va(e,t),userIntentRequired:!1,onSuccessNavigateTo:mt.AWAITING_CONNECTION,onErrorNavigateTo:mt.ERROR_SCREEN}}),ka(mt.CAPTCHA_SCREEN)):(ye(e)?await Ba(e):await Va(e),ka(mt.AWAITING_CONNECTION))},$a=()=>{ie((e=>{let t=T.connectors?.wallets.filter(ye).map((e=>({...e,linked:za(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Se("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Se("Cannot link or login with embedded wallet");qa(e)},fund:async t=>{await sr.fundWallet(e.address,t)},unlink:async()=>{if(!V)throw new Se("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Se("Cannot unlink an embedded wallet");re(await T.unlinkEthereumWallet(e.address))}})))||[];return he(e,t)?e:t})),_e((e=>{let t=T.connectors?.wallets.filter(Ae).map((e=>({...e,linked:za(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Se("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Se("Cannot link or login with embedded wallet");qa(e)},fund:async()=>{throw new Se("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!V)throw new Se("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Se("Cannot unlink an embedded wallet");re(await T.unlinkSolanaWallet(e.address))}})))||[];return he(e,t)?e:t}))};s((()=>{$a()}),[te?.linkedAccounts,V,F]),s((()=>{if(F){if(!T.connectors)throw new Se("Connector not initialized");$a(),T.connectors.on("walletsUpdated",$a)}}),[F]),s((()=>{[...ea.loginMethodsAndOrder?.primary??[],...ea.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>T.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!T]),s((()=>{let e;if(!ne[0])return;let t=ne[0],a=ut.current.find((e=>e.address===t.address));if(e="privy"===t.walletClientType?te?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"===e.walletClientType)):te?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"!==e.walletClientType)),!a&&e){let t=Object.assign({},te);t.wallet=e&&{address:e.address,chainType:e.chainType,chainId:e.chainId,walletClient:e.walletClient,walletClientType:e.walletClientType,connectorType:e.connectorType,imported:e.imported,delegated:e.delegated,walletIndex:e.walletIndex},re(t)}ut.current=ne}),[ne]);let Ya=async(e,t,a)=>{let r=b(e),n=k(e);if(a&&"walletIndex"in a)return Qa(e,t,a.walletIndex,r,n);let i=a&&"createAdditional"in a&&a.createAdditional;if(r&&!i)throw At(ga,"createWallet","onError",Le.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([sr.initializeWalletProxy(t),xa()]);if(!o&&ea.customAuth?.enabled)throw At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||ea.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return Xa();if(!r)return console.log("solanaWallet",n),await o.create({accessToken:s,solanaAddress:n?.address}),Ja(0);{let t=(R(e)?.walletIndex??0)+1,{entropyId:a,entropyIdVerifier:r}=C(W(e));return await sr.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:a,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:t}),Ja(t)}},Xa=async()=>new Promise(((e,t)=>{ra(!0),ia({createWallet:{onSuccess:t=>{At(ga,"createWallet","onSuccess",t),e(t)},onFailure:e=>{At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),Ia(mt.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),Qa=async(e,t,a,r,n)=>{if(a<0)throw At(ga,"createWallet","onError",Le.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${a}) is invalid.`);let[i,o]=await Promise.all([sr.initializeWalletProxy(t),xa()]);if(!i&&ea.customAuth?.enabled)throw At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||ea.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==a)return Xa();throw At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==a){if(r)return r;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!r)throw At(ga,"createWallet","onError",Le.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=U(e).find((e=>e.walletIndex===a));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=C(W(e));await sr.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:a})}return Ja(a)},Ja=async e=>{let t=U(await sr.refreshUser()).find((t=>t.walletIndex===e));if(!t)throw At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return At(ga,"createWallet","onSuccess",t),t},Za=(e,t,r,n)=>new Promise((async(i,o)=>{let{requesterAppId:s}=t||{};if(!V||!te)return At(ga,"sendTransaction","onError",Le.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let l=n??b(te)?.address;if(!l)throw new Se("User must have an embedded wallet to send a transaction.");let{signingWallet:c,rootWallet:d}=P(te,l);if(!d||!c)return At(ga,"sendTransaction","onError",Le.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have a Privy wallet before signing"));ra(!0);let u=lr.wallets.find((e=>"privy"===e.walletClientType&&a(e.address)===a(c.address))),h=await(u?.getEthereumProvider());if(!u||!h)throw new Se(`Cannot sendTransaction before embedded wallet ${c.address} is connected`);let p=e.chainId?Number(e.chainId):Be(u.chainId);(e=>{if(!ea.chains.map((e=>e.id)).includes(e))throw new De(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,Le.UNSUPPORTED_CHAIN_ID)})(p);let w=Object.assign({},e,{chainId:p});if(Ca({showWalletUIs:t?.showWalletUIs}))(async()=>{let e=await xa();if(!e||!Jt)return At(ga,"sendTransaction","onError",Le.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have valid access token and Privy wallet to send transaction"));try{if(!await sr.recoverPrimaryWallet())return At(ga,"sendTransaction","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),void o(Error("Unable to connect to wallet"));let a=J(w.chainId,ea.chains,ea.rpcConfig,{appId:v.appId}),r=await Ut(c.address,w,a);if(Ca({showWalletUIs:t?.showWalletUIs})){let{totalGasEstimate:e}=await Ot(r,a),{hasSufficientFunds:t}=await Ue(c.address,r,e,a);if(!t)throw new pe(new we("Wallet has insufficient funds for this transaction.",St.E32603_DEFAULT_INTERNAL_ERROR.eipCode))}let{entropyId:n,entropyIdVerifier:l}=C(d),u=await Oe({accessToken:e,entropyId:n,entropyIdVerifier:l,transactingWallet:c,walletProxy:Jt,transactionRequest:r,provider:a,requesterAppId:s});At(ga,"sendTransaction","onSuccess",u),i(u)}catch(e){At(ga,"sendTransaction","onError",Le.TRANSACTION_FAILURE),o(e)}})();else{let{entropyId:e,entropyIdVerifier:a}=C(d),n={entropyId:e,entropyIdVerifier:a,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{At(ga,"sendTransaction","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}},l=at(ea)?Nt({address:c.address,appConfig:ea,fundWalletConfig:r,methodScreen:mt.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:w.chainId,comingFromSendTransactionScreen:!0}):void 0;ia({connectWallet:n,sendTransaction:{transactionRequest:w,transactingWallet:c,entropyId:e,entropyIdVerifier:a,onSuccess:e=>{At(ga,"sendTransaction","onSuccess",e),i(e)},onFailure:e=>{At(ga,"sendTransaction","onError",Le.TRANSACTION_FAILURE),o(e)},uiOptions:t||{},fundWalletConfig:r,requesterAppId:s},funding:l}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),er=({transaction:e,connection:t,transactionOptions:a,fundWalletConfig:r,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!V||!te)return At(ga,"sendSolanaTransaction","onError",Le.MUST_BE_AUTHENTICATED),void s(new Se("User must be authenticated before signing with a Privy wallet",Le.MUST_BE_AUTHENTICATED));let c=i?te.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):k(te);if(!c)return At(ga,"sendSolanaTransaction","onError",Le.EMBEDDED_WALLET_NOT_FOUND),void s(new Se("Must have a Privy wallet before signing",Le.EMBEDDED_WALLET_NOT_FOUND));ra(!0);let d=i??Re,u=await(d?.isConnected());if(!d||!u)throw At(ga,"sendSolanaTransaction","onError",Le.EMBEDDED_WALLET_NOT_FOUND),new Se(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,Le.EMBEDDED_WALLET_NOT_FOUND);if(Ca({showWalletUIs:n?.showWalletUIs}))(async()=>{let r=await xa();if(!r||!Jt)return At(ga,"sendSolanaTransaction","onError",Le.EMBEDDED_WALLET_NOT_FOUND),void s(new Se("Must have valid access token and Privy wallet to send transaction",Le.EMBEDDED_WALLET_NOT_FOUND));try{if(!await sr.recoverPrimaryWallet())return At(ga,"sendSolanaTransaction","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),void s(new Se("Unable to connect to wallet",Le.UNKNOWN_CONNECT_WALLET_ERROR));if(Ca({showWalletUIs:n?.showWalletUIs})){let{instructions:a}=await st(e,t);a.every((e=>e.hasFunds))||(At(ga,"sendSolanaTransaction","onError",Le.INSUFFICIENT_BALANCE),s(new Se("Solana wallet has insufficient funds for this transaction.",Le.INSUFFICIENT_BALANCE)))}let{entropyId:i,entropyIdVerifier:l}=N(te),{signature:d,receipt:u}=await je({accessToken:r,tx:e,connection:t,walletProxy:Jt,transactionOptions:a,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=lt(d,u);At(ga,"sendSolanaTransaction","onSuccess",h),o(h)}catch(e){At(ga,"sendSolanaTransaction","onError",Le.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:d}=C(c),u={entropyId:i,entropyIdVerifier:d,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{At(ga,"sendSolanaTransaction","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},h=Wt({address:c.address,appConfig:ea,methodScreen:mt.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:r,comingFromSendTransactionScreen:!0});ia({connectWallet:u,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:a,transactingWallet:c,onSuccess:e=>{At(ga,"sendSolanaTransaction","onSuccess",e),o(e)},onFailure:e=>{At(ga,"sendSolanaTransaction","onError",Le.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:h}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function tr(){return new Promise((async(e,t)=>{let a=await xa();if(!a||!Jt)throw Error("Must have valid access token to enroll in MFA");try{await Jt.verifyMfa({accessToken:a}),e()}catch(e){t(e)}}))}let ar=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],rr=e=>{let t=te?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:a,loginMethod:r}=ct(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw At(ga,"linkAccount","onError",Le.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new Se(`User already has an account of type ${a} linked.`)};async function nr({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){Dt(null);let a=t?"setWalletPassword":"setWalletRecovery";if(!V||!te)throw At(ga,a,"onError",Le.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=W(te);if(!r||!Jt)throw At(ga,a,"onError",Le.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await tr()}catch(e){throw At(ga,a,"onError",Le.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{ra(!0);let o={onSuccess:e=>{At(ga,a,"onSuccess","user-passcode",e),n(e)},onFailure:e=>{At(ga,a,"onError",Le.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===r.recoveryMethod,l=Ze({walletAction:"update",availableRecoveryMethods:ea.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=C(r);ia({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{At(ga,a,"onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function ir({appId:e,action:t}){let a=await xa();if("link"===t&&!a)throw At(ga,"linkAccount","onError",Le.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Se("User must be authenticated before linking an account.");if("login"===t&&a)throw At(ga,"login","onError",Le.UNKNOWN_AUTH_ERROR),new Se("Attempted to log in, but user is already logged in. Use a `link` helper instead.");Aa.current=`privy:${e}`,va.current=t;let r=nt();return T.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(a,n)=>{let{name:i,logoUrl:o}=await qe({api:T.api,providerAppId:e,requesterAppId:ea.id});ia({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:r,onSuccess:a,onError:n}}),ka(mt.CROSS_APP_AUTH_SCREEN)}))}let or={ready:F,authenticated:V,user:te,walletConnectors:T.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),ia({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),Ia(V?mt.CONNECT_ONLY_AUTHENTICATED_SCREEN:mt.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:Ga,startCrossAppAuthFlow:ir,linkEmail:()=>{Ka("email"),rr("email"),Aa.current="email",va.current="link",Ia(mt.LINK_EMAIL_SCREEN)},linkPhone:()=>{Ka("sms"),rr("phone"),Aa.current="sms",va.current="link",Ia(mt.LINK_PHONE_SCREEN)},linkGoogle:async()=>{Ka("google"),rr("google_oauth"),va.current="link",await sr.initLoginWithOAuth("google")},linkTwitter:async()=>{Ka("twitter"),rr("twitter_oauth"),va.current="link",await sr.initLoginWithOAuth("twitter")},linkDiscord:async()=>{Ka("discord"),rr("discord_oauth"),va.current="link",await sr.initLoginWithOAuth("discord")},linkGithub:async()=>{Ka("github"),rr("github_oauth"),va.current="link",await sr.initLoginWithOAuth("github")},linkSpotify:async()=>{Ka("spotify"),rr("spotify_oauth"),va.current="link",await sr.initLoginWithOAuth("spotify")},linkInstagram:async()=>{Ka("instagram"),rr("instagram_oauth"),va.current="link",await sr.initLoginWithOAuth("instagram")},linkTiktok:async()=>{Ka("tiktok"),rr("tiktok_oauth"),va.current="link",await sr.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{Ka("linkedin"),rr("linkedin_oauth"),va.current="link",await sr.initLoginWithOAuth("linkedin")},linkApple:async()=>{Ka("apple"),rr("apple_oauth"),va.current="link",await sr.initLoginWithOAuth("apple")},linkPasskey:async()=>{Ka("passkey"),rr("passkey"),await sr.initLinkWithPasskey(),Ia(mt.LINK_PASSKEY_SCREEN)},linkTelegram:async()=>{Ka("telegram"),rr("telegram"),va.current="link",Aa.current="telegram",await sr.initLoginWithTelegram(),Ia(mt.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{Ka("farcaster"),rr("farcaster"),await sr.initLoginWithFarcaster(),va.current="link",Aa.current="farcaster",Ia(mt.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(Ka("email"),!te?.email)throw new Se("User does not have an email linked to their account.");va.current="update",Aa.current="email",Ia(mt.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(Ka("sms"),!te?.phone)throw new Se("User does not have a phone number linked to their account.");va.current="update",Aa.current="sms",Ia(mt.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!F){let e=await new Promise((e=>{sa((t=>e.bind(t)))}));if(sa(null),e)return void console.warn(t)}!te||te.isGuest?(va.current="login",ia({login:e}),ka(mt.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{F||(await new Promise((e=>{sa((()=>e))})),sa(null)),V?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(va.current="login",ka(mt.CONNECT_OR_CREATE))},logout:async()=>{if(va.current=null,Aa.current=null,te&&T.clearProviderAcccessTokens(te),Dt(null),await T.logout(),te&&Jt)try{await Jt.clearMfa({userId:te.id})}catch(e){}re(null),H(!1),At(ga,"logout","onSuccess"),D(!1),X.del(B),X.del(K(ea.id))},getAccessToken:()=>T.getCustomerAccessToken(),getEthereumProvider:()=>{if(!te||!te.wallet)return new fe;let e=ne.find((e=>te.wallet&&e.address===te.wallet.address)),t=T.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new fe},getEthersProvider:()=>{if(!te||!te.wallet)return new r(new ge(new fe));let e=ne.find((e=>te.wallet&&e.address===te.wallet.address)),t=T.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new r(new ge(e&&t?t.proxyProvider:new fe))},getWeb3jsProvider:()=>{if(!te||!te.wallet)return new Ee(new fe);let e=ne.find((e=>te.wallet&&e.address===te.wallet.address)),t=T.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new Ee(e&&t?t.proxyProvider:new fe)},unlinkWallet:async e=>{let t;return re(t=e.startsWith("0x")?await T.unlinkEthereumWallet(e):await T.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await T.unlinkEmail(e);return re(t),t},unlinkPhone:async e=>{let t=await T.unlinkPhone(e);return re(t),t},unlinkGoogle:async e=>{let t=await T.unlinkOAuth("google",e);return re(t),t},unlinkTwitter:async e=>{let t=await T.unlinkOAuth("twitter",e);return re(t),t},unlinkDiscord:async e=>{let t=await T.unlinkOAuth("discord",e);return re(t),t},unlinkGithub:async e=>{let t=await T.unlinkOAuth("github",e);return re(t),t},unlinkSpotify:async e=>{let t=await T.unlinkOAuth("spotify",e);return re(t),t},unlinkInstagram:async e=>{let t=await T.unlinkOAuth("instagram",e);return re(t),t},unlinkTiktok:async e=>{let t=await T.unlinkOAuth("tiktok",e);return re(t),t},unlinkLinkedIn:async e=>{let t=await T.unlinkOAuth("linkedin",e);return re(t),t},unlinkApple:async e=>{let t=await T.unlinkOAuth("apple",e);return re(t),t},unlinkFarcaster:async e=>{let t=await T.unlinkFarcaster(e);return re(t),t},unlinkTelegram:async e=>{let t=await T.unlinkTelegram(e);return re(t),t},unlinkPasskey:async e=>{let t=await T.unlinkPasskey(e);return re(t),t},unlinkCrossAppAccount:async({subject:e})=>{let t=te?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Se("Invalid subject");T.storeProviderAccessToken(t.id,null);let a=await T.unlinkOAuth(`privy:${t.id}`,e);return re(a),a},setActiveWallet:async e=>{let t=ne.find((t=>a(t.address)===a(e))),r=te?.linkedAccounts.find((t=>"wallet"===t.type&&a(t.address)===a(e)));if(t&&await t.isConnected())if(t.linked){let e=Object.assign({},te);e.wallet=r&&{address:r.address,chainType:r.chainType,chainId:r.chainId,walletClient:r.walletClient,walletClientType:r.walletClientType,connectorType:r.connectorType,imported:r.imported,delegated:r.delegated,walletIndex:r.walletIndex},re(e)}else t.loginOrLink();else ia({externalConnectWallet:{suggestedAddress:e}}),Ga()},forkSession:()=>T.forkSession(),createWallet:async e=>{if(e&&"target"in e&&e&&(e=void 0),!V||!te)throw At(ga,"createWallet","onError",Le.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return Ya(te,15e3,e)},setWalletRecovery:async e=>nr({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>nr({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t,a)=>new Promise((async(r,n)=>{let{requesterAppId:i}=t||{};if(!V||!te)return At(ga,"signMessage","onError",Le.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=a??b(te)?.address;if(!o)throw new Se("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=P(te,o);if(!s||!l)return At(ga,"signMessage","onError",Le.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return At(ga,"signMessage","onError",Le.INVALID_MESSAGE),void n(Error("Message must be a non-empty string"));ra(!0);let c=async()=>{if(!V)throw Error("User must be authenticated before signing with a Privy wallet");let t=await xa();if(!Jt||!t||!await sr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");T.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:a,entropyIdVerifier:r}=C(l),{response:n}=await Jt.rpc({accessToken:t,entropyId:a,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"personal_sign",params:[e,s.address]}}),o=n.data;return T.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:i}}),o};if(Ca({showWalletUIs:t?.showWalletUIs}))try{let e=await c();At(ga,"signMessage","onSuccess",e),r(e)}catch(e){At(ga,"signMessage","onError",Le.UNABLE_TO_SIGN),n(e??new pe("Unable to sign message"))}else{let{entropyId:a,entropyIdVerifier:i}=C(l);ia({signMessage:{method:"personal_sign",data:e,confirmAndSign:c,onSuccess:e=>{At(ga,"signMessage","onSuccess",e),r(e)},onFailure:e=>{At(ga,"signMessage","onError",Le.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:a,entropyIdVerifier:i,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{At(ga,"signMessage","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t,a)=>new Promise((async(r,n)=>{let{requesterAppId:i}=t||{};if(!V||!te)return At(ga,"signTypedData","onError",Le.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=a??b(te)?.address;if(!o)throw new Se("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=P(te,o);if(!l||!s)return At(ga,"signTypedData","onError",Le.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));ra(!0);let c=Z(e),d=async()=>{if(!V)throw Error("User must be authenticated before signing with a Privy wallet");let e=await xa();if(!Jt||!e||!await sr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");T.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:t,entropyIdVerifier:a}=C(l),{response:r}=await Jt.rpc({accessToken:e,entropyId:t,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"eth_signTypedData_v4",params:[s.address,c]}}),n=r.data;return T.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:s.address,requesterAppId:i}}),n};if(Ca({showWalletUIs:t?.showWalletUIs,typedData:!0}))try{let e=await d();At(ga,"signTypedData","onSuccess",e),r(e)}catch(e){At(ga,"signTypedData","onError",Le.UNABLE_TO_SIGN),n(e??new pe("Unable to sign message"))}else{let{entropyId:e,entropyIdVerifier:a}=C(l);ia({signMessage:{method:"eth_signTypedData_v4",data:c,confirmAndSign:d,onSuccess:e=>{At(ga,"signTypedData","onSuccess",e),r(e)},onFailure:e=>{At(ga,"signTypedData","onError",Le.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:e,entropyIdVerifier:a,onCompleteNavigateTo:mt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{At(ga,"signMessage","onError",Le.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t,a,r)=>{let n=await Za(e,t,a,r);return be(await n.wait())},sendSolanaTransaction:async(e,t,a,r,n)=>await er({transaction:e,connection:t,transactionOptions:r,uiOptions:a,fundWalletConfig:n,wallet:Re??void 0}),exportWallet:e=>new Promise((async(t,a)=>{if(!V||!te)return void a(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let r=e?.address??b(te)?.address;if(!r)return void a(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=P(te,r);if(!n||!i)return void a(Error("Must have a Privy wallet before exporting"));ra(!0);let{entropyId:o,entropyIdVerifier:s}=C(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:mt.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:a,shouldForceMFA:!0};ia(na),await xa()&&Jt?Jt?(ia({keyExport:{appId:v.appId,appClientId:v.clientId,origin:T.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:a},connectWallet:l}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)):a(Error("Must have a Privy wallet before exporting")):a(Error("Must have valid access token to enroll in MFA"))})),promptMfa:tr,async init(e){switch(e){case"sms":return void await T.initMfaSmsVerification();case"passkey":return await T.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Se("Invalid MFA code");ya.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{fa.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Se("Invalid authenticator response");let a=await import("@simplewebauthn/browser"),r=dt(await a.startAuthentication(t));ya.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{fa.current={resolve:e,reject:t}}));break;default:throw ya.current?.reject(new Se("Unsupported MFA method")),new Se(`Unsupported MFA method: ${e}`)}},cancel(){ya.current?.reject(new Se("MFA canceled"))},async initEnrollmentWithSms(e){let t=await xa();if(!t||!Jt)throw Error("Must have valid access token to enroll in MFA");await Jt.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,a)=>{if(!e)return sr.closePrivyModal(),void t();ea.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),ia({mfaEnrollmentFlow:{mfaMethods:ea.mfa.methods,onSuccess:t,onFailure:a}}),Ia(mt.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await xa();if(!e||!Jt)throw Error("Must have valid access token to enroll in MFA");let t=await Jt.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await xa();if(!t||!Jt)throw Error("Must have valid access token to enroll in MFA");await Jt.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),re(await T.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await xa();if(!t||!Jt)throw Error("Must have valid access token to enroll in MFA");await Jt.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),re(await T.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e}){let t=await xa();if(!t||!Jt)throw Error("Must have valid access token to enroll in MFA");await Jt.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:e}),re(await T.getAuthenticatedUser())},async unenroll(e){let t=await xa();if(!t||!Jt)throw Error("Must have valid access token to remove MFA");"passkey"===e?await Jt.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:[]}):await Jt.unenrollMfa({method:e,accessToken:t}),re(await T.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await xa(),t=te?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!Jt||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!te?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await sr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let a=await Jt.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===a.status&&re(await T.getAuthenticatedUser()||te||null),ia({farcasterSigner:a}),Ia(mt.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await xa(),a=te?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!Jt||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!te?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await sr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!te.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=te.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await xa(),a=te?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!Jt||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!te?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await sr.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!te.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let r=await import("@simplewebauthn/browser"),n=await Jt.signFarcasterMessage({address:a.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(te.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(te&&!te.isGuest)throw Error("User cannot already be authenticated to create a guest account");return te?.isGuest?te:sr.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t}){let a=te?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ye({user:te,client:T,address:t,requesterAppId:ea.id,request:{method:a?"privy_signSmartWalletMessage":"personal_sign",params:[e,t]},reconnect:ir})},signTypedDataWithCrossAppWallet(e,{address:t}){let a=te?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),r=Z(e);return Ye({user:te,client:T,address:t,requesterAppId:ea.id,request:{method:a?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,r]},reconnect:ir})},sendTransactionWithCrossAppWallet(e,{address:t}){let a=te?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return Ye({user:te,client:T,address:t,requesterAppId:ea.id,request:{method:a?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e]},reconnect:ir})},isModalOpen:M,mfaMethods:ea.mfa.methods};Sa=or.signMessage,Ra=or.signTypedData,Pa=async(...e)=>{let t=await Za(...e);return ea.embeddedWallets.waitForTransactionConfirmation&&await t.wait(),t};let sr={isNewUserThisSession:Pt,pendingTransaction:null,walletConnectionStatus:jt,connectors:T.connectors?.walletConnectors??[],solanaWallets:ce,rpcConfig:ea.rpcConfig,chains:ea.chains,appId:v.appId,showFiatPrices:"native-token"!==ea.embeddedWallets.priceDisplay.primary,clientAnalyticsId:T.clientAnalyticsId,customAuthStatus:wa,noPromptOnSignature:Ta,emailOtpState:Kt,setEmailOtpState:Gt,smsOtpState:zt,setSmsOtpState:qt,oAuthState:Xt,setOAuthState:Qt,siweState:$t,setSiweState:Yt,isHeadlessOAuthLoading:Ft,nativeTokenSymbolForChainId:e=>ea.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(Jt)return Jt;let t=new Promise((e=>{ca((()=>t=>e(t)))})),a=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,a]);return ca(null),r},getAuthFlow:()=>T.authFlow,getAuthMeta:()=>T.authFlow?.meta,client:T,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=F&&V&&te;a&&Aa.current&&(t=ar(te)),"login"===va.current?e.shouldCallAuthOnSuccess&&a&&Aa.current?(At(ga,"login","onComplete",te,Pt,!1,Aa.current,t??null),v.onSuccess?.(te,Pt)):At(ga,"login","onError",Le.USER_EXITED_AUTH_FLOW):"link"===va.current&&t?e.isSuccess&&a&&Aa.current?At(ga,"linkAccount","onSuccess",te,Aa.current,t):Aa.current&&At(ga,"linkAccount","onError",Le.USER_EXITED_LINK_FLOW,{linkMethod:Aa.current}):"update"===va.current&&t&&(e.isSuccess&&a&&Aa.current?At(ga,"update","onSuccess",te,Aa.current,t):Aa.current&&At(ga,"update","onError",Le.USER_EXITED_UPDATE_FLOW,{linkMethod:Aa.current}));let r=Mt&&et.includes(Mt),n=Mt===mt.ERROR_SCREEN&&na.errorModalData&&et.includes(na.errorModalData.previousScreen);if((r||n)&&na.funding){let e,t=tt[Mt]??null;if("solana"===na.funding.chainType){let a=I(pt);if(!a)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await a.getBalance({address:na.funding.address,cluster:na.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}At(ga,"fundSolanaWallet","onUserExited",{address:na.funding.address,cluster:na.funding.cluster,fundingMethod:t,balance:e})}else{let a=J(na.funding.chain.id,ea.chains,ea.rpcConfig,{appId:v.appId});try{e=(await a.getBalance(na.funding.address)).toBigInt()}catch{console.error("Unable to pull wallet balance")}At(ga,"fundWallet","onUserExited",{address:na.funding.address,chain:na.funding.chain,fundingMethod:t,balance:e})}}ia({...na,externalConnectWallet:{suggestedAddress:void 0}}),va.current=null,Aa.current=null,Lt(!1),D(!1),setTimeout((()=>{T.authFlow=void 0}),200),T.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:async({message:e})=>new Promise((async(t,a)=>{let r=async()=>{let t=await T.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");if(!Re)throw Error("User must have an embedded Solana wallet to sign messages for Solana.");let a=sr.walletProxy??await sr.initializeWalletProxy(15e3);if(!a)throw Error("Failed to initialize embedded wallet proxy.");let{entropyId:r,entropyIdVerifier:n}=N(te),{response:i}=await a.rpc({accessToken:t,entropyId:r,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:Re.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return i.data.signature};if(Ca({showWalletUIs:void 0}))try{let e=await r();t({signature:e})}catch(e){a(e)}else ia({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:r,onSuccess:e=>{t({signature:e})},onFailure:e=>{a(e)},uiOptions:{}}}),ka(mt.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN)})),openPrivyModal:Ia,connectWallet:ja,initLoginWithWallet:async(e,t,a)=>{ye(e)?(Aa.current="siwe",Ba(e,t,a)):(Aa.current="siws",Va(e,t))},loginWithWallet:async()=>{let e,t,a;if(!F)throw new Me;if(T.authFlow instanceof y?e="siwe":T.authFlow instanceof f&&(e="siws"),!e)throw new Se("Must initialize SIWE/SIWS flow first.");if(null!==await T.getAccessToken())try{({user:t}=await T.link()),Aa.current=e}catch(t){throw At(ga,"linkAccount","onError",t.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:a}=await T.authenticate()),Aa.current=e}catch(e){throw At(ga,"login","onError",e.privyErrorCode||Le.GENERIC_CONNECT_WALLET_ERROR),e}re(t||te||null),Lt(a||!1),H(!0)},delegateWallet:async({address:e,chainType:t})=>new Promise((async(a,r)=>{let n=await xa();if(!V||!te||!n)throw new Se("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Se("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let i=sr.walletProxy??await sr.initializeWalletProxy(15e3);if(!i)throw new Se("Wallet proxy not initialized.");if(Ce({address:e,chainType:t,user:te}))throw new Se(`Wallet with address ${e} is already delegated.`);let o=Ie({address:e,user:te}),s=ke({address:e,user:te});await sr.recoverPrimaryWallet(),ia({delegatedActions:{consent:{address:e,onDelegate:async()=>{await i.createDelegatedAction({accessToken:n,rootWallet:s,delegatedWallets:[o]}),await sr.refreshUser()},onSuccess:async()=>{a()},onError:async e=>{r(e)}}}}),Ia(mt.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async()=>new Promise((async(e,t)=>{if(!V||!te)throw new Se("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===We(te).length)throw new Se("User has no delegated wallets to revoke.");ia({delegatedActions:{revoke:{onRevoke:async()=>{await T.revokeDelegatedWallet(),await sr.refreshUser()},onSuccess:async()=>{e()},onError:async e=>{t(e)}}}}),Ia(mt.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN)})),initLoginWithFarcaster:async(e,t)=>{let a=new p(e,t);T.startAuthFlow(a);try{Aa.current="farcaster",await a.initializeFarcasterConnect()}catch(e){throw"login"===va.current?At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR):"link"===va.current&&At(ga,"linkAccount","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!F)throw new Me;if(!(T.authFlow instanceof p))throw new Se("Must initialize Farcaster flow first.");if(null!==await T.getAccessToken())try{({user:e}=await T.link()),Aa.current="farcaster"}catch(e){throw At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await T.authenticate()),Aa.current="farcaster"}catch(e){throw At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}re(e||null),Lt(t||!1),H(!0)},async loginWithGuestAccountFlow(){let e=new w(this.appId);T.startAuthFlow(e);try{va.current="login",Aa.current="guest";let{user:e,isNewUser:t}=await T.authenticate();if(t=t||!1,!e)throw new Se("Unable to authenticate guest account");if(S(e,ea.embeddedWallets.createOnLogin))try{await Ya(e,15e3),e=await sr.refreshUser()}catch(t){re(e),console.warn("Unable to create embedded wallet for guest account")}else re(e);return Lt(t),H(!0),At(ga,"login","onComplete",e,t,!1,"guest",null),e}catch(e){throw At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:a}){let r=`privy:${e}`;Aa.current=r;let{url:n,stateCode:i,codeVerifier:o}=await Ge({api:T.api,appId:e});if(!n)throw T.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Se("No authorization URL returned for cross-app auth.");try{let s=await $e({url:n,popup:t,provider:r}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw T.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:i??"",returnedStateCode:l??""}}),new Se("Unexpected auth flow. This may be a phishing attempt.",void 0,Le.OAUTH_UNEXPECTED);let d=await ze({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:a,client:T});d&&T.storeProviderAccessToken(e,d);let u=await sr.refreshUser();if(!u)throw new Se("Unable to update user");return T.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw T.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:r}}),e}},async initLoginWithOAuth(e,t,a){if(Aa.current=e,!Q())return void ka(mt.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&rt(window.navigator.userAgent))return void ka(mt.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:Ve},"*"),X.del(G),X.del(z);let r=new Rt({provider:e,disableSignup:!!a,withPrivyUi:!0});t&&r.addCaptchaToken(t),T.startAuthFlow(r);let n=await T.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&c&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!F)throw new Me;Aa.current="telegram";let a=new _(e,t);T.startAuthFlow(a),a.meta.telegramWebAppData=void 0,a.meta.telegramAuthResult=await new Promise(((e,t)=>ea.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:ea.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(a=>a?e(a):t(new Se("Telegram auth failed or was canceled by the client")))):t(new Se("Telegram was not initialized")):t(new Se("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,a;if(!(T.authFlow instanceof _))throw new Se("Must initialize Telegram flow before calling loginWithTelegram");if(T.authFlow.meta.captchaToken||=e,"login"===va.current)try{let e=await T.authenticate();t=e.user,a=e.isNewUser,Aa.current="telegram"}catch(e){throw At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}else{if("link"!==va.current)throw new Se("Unknown auth intent");try{t=(await T.link()).user,Aa.current="telegram"}catch(e){throw At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}re(t),Lt(a||!1),H(!0)},async recoveryOAuthFlow(e,t,a){let r,n;function i(t){if(!t)throw T.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new Se("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await Xe({api:Oa.api,provider:e});i(s);try{let r=await it({url:s,popup:a,provider:e});if(t=r.stateCode,o=r.authorizationCode,t!==c)throw T.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new Se("Unexpected auth flow. This may be a phishing attempt.",void 0,Le.OAUTH_UNEXPECTED)}catch(t){throw T.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new Se("Recovery OAuth failed")}[r,n]=await Promise.all([xa(),Qe({api:Oa.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await Xe({api:Oa.api,provider:e});i(t);let{ckWebAuthToken:o}=await it({url:t,popup:a,provider:e});n=o,r=await xa()}}if(!Jt)throw new Se("Cannot connect to wallet proxy");if(!r)throw new Se("Unable to authorize user");switch(t){case"recover":{let t=na.recoverWallet?.entropyId,a=na.recoverWallet?.entropyIdVerifier;if(!t||!a)throw new Se("Recovery OAuth failed");T.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await Jt.recover({accessToken:r,entropyId:t,entropyIdVerifier:a,recoveryAccessToken:n}),T.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{T.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await Jt.create({accessToken:r,recoveryAccessToken:n,recoveryMethod:e});let t=b(await sr.refreshUser());if(!t)throw At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");T.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),At(ga,"createWallet","onSuccess",t);break}case"set-recovery":{let t=W(te);if(!t)throw At(ga,"setWalletRecovery","onError",Le.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");T.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:a,entropyIdVerifier:i}=C(t);await Jt.setRecovery({accessToken:r,entropyId:a,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=W(await sr.refreshUser());if(!o)throw At(ga,"createWallet","onError",Le.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");T.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),At(ga,"setWalletRecovery","onSuccess",e,o);break}default:throw new Se("Unsupported recovery action")}},async loginWithOAuth(e){let t,a,r;if(!(T.authFlow instanceof Rt))throw new Se("Must initialize OAuth flow before calling loginWithOAuth");let n=X.get(q),i=T.authFlow.meta.stateCode;if(n!==i)throw T.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new Se("Unexpected auth flow. This may be a phishing attempt.",void 0,Le.OAUTH_UNEXPECTED);if(null!==await T.getAccessToken())try{let a=await T.link();t=a.user,r=a.oAuthTokens,Aa.current=e}catch(t){throw At(ga,"linkAccount","onError",t.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await T.authenticate();t=n.user,a=n.isNewUser,r=n.oAuthTokens,Aa.current=e}catch(t){throw"login"===va.current?At(ga,"login","onError",t.privyErrorCode||Le.UNKNOWN_AUTH_ERROR):"link"===va.current&&At(ga,"linkAccount","onError",t.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return re(t),Lt(a||!1),H(!0),r&&t&&At(ga,"oAuthAuthorization","onOAuthTokenGrant",r,{user:t}),r},passkeyAuthState:Vt,setPasskeyAuthState:Ht,async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let a=new m({captchaToken:e,setPasskeyAuthState:Ht});T.startAuthFlow(a),va.current="login";try{Aa.current="passkey",Ht({status:"generating-challenge"}),await a.initAuthenticationFlow(t),Ht({status:"awaiting-passkey"})}catch(e){throw Ht({status:"error",error:e}),At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!F)throw new Me;if(!(T.authFlow instanceof m))throw new Se("Must initialize Passkey flow first.");if("passkey"!==Aa.current){let e=new Se("Must init login with Passkey flow first.");throw Ht({status:"error",error:e}),e}let a=await xa();try{Aa.current="passkey",Ht({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await T.authenticate())}catch(e){throw Ht({status:"error",error:e}),At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}re(e),Lt(t||!1),H(!0),Ht({status:"done"});let r=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!a,loginAccount:r}},async initLinkWithPasskey(e){let t=new m({captchaToken:e});T.startAuthFlow(t),va.current="link",Aa.current="passkey",Ht({status:"generating-challenge"});try{await t.initLinkFlow(),Ht({status:"awaiting-passkey"})}catch(e){throw At(ga,"linkAccount","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),Ht({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!F)throw new Me;if(!(T.authFlow instanceof m))throw new Se("Must initialize Passkey flow first.");if("passkey"!==Aa.current)throw new Se("Must init login with Passkey flow first.");try{Aa.current="passkey",({user:e}=await T.link())}catch(e){throw At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return re(e||te||null),Ht({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,a){if(!Q())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&rt(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let r=new Rt({provider:e,withPrivyUi:!1,disableSignup:a??!1});t&&r.addCaptchaToken(t),Qt({status:"loading"});let n=await T.startAuthFlow(r).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,a,r;xt(!0),Qt({status:"loading"}),T.startAuthFlow(new Rt(e));let n=X.get(q),i=e.stateCode;if(n!==i)throw T.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),xt(!1),new Se("Unexpected auth flow. This may be a phishing attempt.",void 0,Le.OAUTH_UNEXPECTED);if(null!==await T.getAccessToken())try{({user:t,oAuthTokens:r}=await T.link()),Aa.current=e.provider;let a=ar(t);t&&a&&At(ga,"linkAccount","onSuccess",t,Aa.current,a)}catch(t){throw xt(!1),At(ga,"linkAccount","onError",t.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:a,oAuthTokens:r}=await T.authenticate()),Aa.current=e.provider;let n=ar(t);t&&n&&void 0!==a&&At(ga,"login","onComplete",t,a,!1,Aa.current,n)}catch(e){throw xt(!1),Qt({status:"error",error:e}),At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}return re(t),Lt(a||!1),H(!0),xt(!1),Qt({status:"done"}),r&&t&&At(ga,"oAuthAuthorization","onOAuthTokenGrant",r,{user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:a,withPrivyUi:r})=>{let n=new h({email:e,captchaToken:t,disableSignup:a});T.startAuthFlow(n);try{Aa.current="email",Gt({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:r}),Gt({status:"awaiting-code-input"})}catch(e){throw Gt({status:"error",error:e}),"login"===va.current?At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR):"link"===va.current&&At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,a)=>{let r=new u(e,t,a);T.startAuthFlow(r);try{await r.sendCodeEmail({withPrivyUi:!0})}catch(e){At(ga,"update","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR,{linkMethod:Aa.current})}},initUpdatePhone:async(e,t,a)=>{let r=new g(e,t,a);T.startAuthFlow(r);try{await r.sendSmsCode({withPrivyUi:!0})}catch(e){At(ga,"update","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR,{linkMethod:Aa.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:a,withPrivyUi:r})=>{qt({status:"sending-code"});let n=new E({phoneNumber:e,captchaToken:t,disableSignup:a});T.startAuthFlow(n);try{Aa.current="sms",await n.sendSmsCode({withPrivyUi:r}),qt({status:"awaiting-code-input"})}catch(e){throw qt({status:"error",error:e}),"login"===va.current?At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR):"link"===va.current&&At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(T.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(T.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,a;function r(e){T.authFlow instanceof h?Gt(e):T.authFlow instanceof E&&qt(e)}if(r({status:"submitting-code"}),!F){let e=new Me;throw r({status:"error",error:e}),e}if(T.authFlow instanceof h)T.authFlow.meta.emailCode=e.trim();else{if(!(T.authFlow instanceof E)){let e=new Se("Must initialize a passwordless code flow first");throw r({status:"error",error:e}),e}T.authFlow.meta.smsCode=e.trim()}let n=await xa();if("link"===va.current)try{({user:t}=await T.link())}catch(e){throw r({status:"error",error:e}),At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:Aa.current}),e}else if("update"===va.current)try{({user:t}=await T.link())}catch(e){throw r({status:"error",error:e}),At(ga,"update","onError",e.privyErrorCode||Le.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:Aa.current}),e}else try{({user:t,isNewUser:a}=await T.authenticate())}catch(e){throw r({status:"error",error:e}),At(ga,"login","onError",e.privyErrorCode||Le.UNKNOWN_AUTH_ERROR),e}let i=t||te;re(i||null),Lt(a||!1),H(!0),r({status:"done"});let o=null;return T.authFlow instanceof h?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:T.authFlow instanceof E&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:a||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:a})=>{va.current="link",Aa.current="siwe",Yt({status:"generating-message"});let r=await T.generateSiweNonce({address:e,captchaToken:a});return Yt({status:"awaiting-signature"}),ot({address:e,chainId:t.replace("eip155:",""),nonce:r})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let a=await T.generateSiweNonce({address:e});return ot({address:e,chainId:t.replace("eip155:",""),nonce:a})},linkSmartWallet:async({message:e,signature:t,smartWalletType:a})=>{let r;try{r=await T.linkSmartWallet({message:e,signature:t,smartWalletType:a}),r=await sr.refreshUser()??r}catch(e){throw e}re(r||te||null)},linkWithSiwe:async({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n})=>{let i;Ka("siwe");let o=null;try{Yt({status:"submitting-signature"}),i=await T.linkWithSiwe({message:e,signature:t,chainId:a,walletClientType:r,connectorType:n}),i=await sr.refreshUser()??i,Yt({status:"done"}),(o=ar(i)||null)&&At(ga,"linkAccount","onSuccess",i,"siwe",o)}catch(e){throw At(ga,"linkAccount","onError",e.privyErrorCode||Le.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),va.current=null,Aa.current=null,Yt({status:"error",error:e}),e}let s=i||te;return re(s||null),va.current=null,Aa.current=null,{user:s,linkedAccount:o}},refreshUser:async()=>{let e=await T.getAuthenticatedUser();return H(!!e),re(e),e},walletProxy:Jt,createAnalyticsEvent:({eventName:e,payload:t,timestamp:a})=>T.createAnalyticsEvent({eventName:e,payload:t,timestamp:a}),acceptTerms:async()=>{let e=await T.acceptTerms();return re(e),e},getUsdTokenPrice:e=>T.getUsdTokenPrice(e),getUsdPriceForSol:()=>T.getUsdPriceForSol(),recoverPrimaryWallet:async e=>new Promise((async(t,a)=>{let r=W(e?.user??te)||O(e?.user??te),n=await xa();if(!n||!Jt||!r)return void a(Error("Must have valid access token and Privy wallet to recover wallet"));ra(!0);let{entropyId:i,entropyIdVerifier:o}=C(r);try{await Jt.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){Ne(e)&&"privy"===r.recoveryMethod?(T.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:r.address}}),(await Jt.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||a(Error("Unable to recover wallet")),T.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:r.address}}),t(!0)):Ne(e)&&"privy"!==r.recoveryMethod?(ia({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:a,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:r.recoveryMethod,action:"recover"}}),Ia(Je(r.recoveryMethod))):a(e)}})),embeddedSolanaWallet:Re,createEmbeddedSolanaWallet:async()=>{ra(!0);let e=await xa(),t=await sr.refreshUser(),a=k(t),r=b(t);if(!t||!e)throw new Se("User must be logged in to create a Solana wallet");if(a)throw new Se("User already has an embedded Solana wallet.");r&&await sr.recoverPrimaryWallet({user:t});let n=await sr.initializeWalletProxy(15e3);if(!n)throw new Se("Unable to initialize wallet proxy");T.createAnalyticsEvent({eventName:"embedded_solana_wallet_creation_started"});try{await n.createSolana({accessToken:e,ethereumAddress:r?.address});let t=await sr.refreshUser(),a=k(t);if(!a)throw new Se("Could not get Solana wallet for user");return T.createAnalyticsEvent({eventName:"embedded_solana_wallet_creation_completed",payload:{walletAddress:a.address}}),a}catch(e){throw T.createAnalyticsEvent({eventName:"embedded_solana_wallet_creation_failed"}),new Se("Failed to create Solana embedded wallet with error ",e)}},exportSolanaWallet:e=>new Promise((async(t,a)=>{if(!V||!te)return void a(Error("User must be authenticated before exporting their Privy wallet"));let r=e?.address??k(te)?.address;if(!r)return void a(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=L(te,r);if(!n||!i)return void a(Error("Must have a Privy wallet before exporting"));if(ra(!0),!await xa()||!Jt)return void a(Error("Must have valid access token to enroll in MFA"));if(!Jt)return void a(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=C(i);ia({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:mt.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:a,shouldForceMFA:!0},keyExport:{appId:v.appId,appClientId:v.clientId,origin:T.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:a}}),Ia(mt.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{j(!0),oa?.(e)},updateWallets:()=>$a(),fundWallet:async(e,t)=>{let a=mt.FUNDING_METHOD_SELECTION_SCREEN;ia({funding:Nt({address:e,appConfig:ea,fundWalletConfig:t,methodScreen:a})}),Ia(a)},openModal:Ia,requestFarcasterSignerStatus:async e=>{let t=await xa(),a=te?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!Jt||!a)throw Error("Must have an embedded wallet to use Farcaster signers");if(!te?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let r=await T.requestFarcasterSignerStatus(e);return"approved"===r.status&&re(await T.getAuthenticatedUser()||te||null),r},connectCoinbaseSmartWallet:async()=>{ea.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=T.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||T.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),ja(e);await Fa("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o})=>{try{let s=await T.sendAccountTransferRequest({nonce:e,account:t,accountType:a,externalWalletMetadata:r,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o});return re(s),s}catch(e){throw e}}};La=sr.recoverPrimaryWallet,Ma=sr.recoverPrimaryWallet,Da=sr.solanaSignMessage;let lr=l((()=>({wallets:ne,ready:da&&Ea})),[ne,da,Ea]),cr=T.authFlow instanceof _,dr=!ea.headless&&ea.captchaEnabled&&!V&&(F||cr);/*#__PURE__*/return e(It.Provider,{value:or,children:/*#__PURE__*/e(vt.Provider,{value:ga,children:/*#__PURE__*/e(kt.Provider,{value:lr,children:/*#__PURE__*/e(Et,{...ea,children:/*#__PURE__*/t(Tt.Provider,{value:sr,children:[/*#__PURE__*/e(wt,{children:/*#__PURE__*/t(Ct,{data:na,setModalData:ia,setInitialScreen:Dt,initialScreen:Mt,authenticated:V,open:M,children:[v.children,dr&&/*#__PURE__*/e(oe,{delayedExecution:!1}),/*#__PURE__*/e(ft,{theme:{...ea.appearance.palette||{}}}),!ea.render.standalone&&/*#__PURE__*/e(se,{open:M})]})}),aa&&ta?/*#__PURE__*/e(Te,{appId:v.appId,appClientId:v.clientId,clientAnalyticsId:T.clientAnalyticsId,origin:T.apiUrl,mfaMethods:te?.mfaMethods,mfaPromise:ya,mfaSubmitPromise:fa,onLoad:Zt,onLoadFailed:()=>null}):null,ea.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/e(yt,{$if:!0,children:/*#__PURE__*/e(le,{scriptHost:v.apiUrl||x,botUsername:ea.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};export{Ta as C,va as E,za as P,Na as a,Ua as b,xa as c,ja as d,Ba as e,Va as f,Fa as g,Ha as h,Ka as i,Ga as j,Ca as l};
