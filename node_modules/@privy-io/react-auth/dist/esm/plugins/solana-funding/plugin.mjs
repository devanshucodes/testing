import{Connection as e,PublicKey as a,Transaction as t,SystemProgram as n,TransactionInstruction as r,VersionedTransaction as s,TransactionMessage as o}from"@solana/web3.js";import{SOLANA_FUNDING_PLUGIN_ID as c}from"./id.mjs";function i({name:e,rpcUrl:a}){if(a)return a;switch(e){case"mainnet-beta":return"https://api.mainnet-beta.solana.com";case"testnet":return"https://api.testnet.solana.com";case"devnet":return"https://api.devnet.solana.com"}}var l={id:c,getBalance:({address:t,cluster:n})=>new e(i(n)).getBalance(new a(t)),createTransferTransaction:async({from:r,to:s,amount:o,cluster:c})=>{let l=new a(r),m=new t;m.add(n.transfer({fromPubkey:l,toPubkey:new a(s),lamports:o}));let u=new e(i(c)),p=await u.getLatestBlockhash();return m.recentBlockhash=p.blockhash,m.feePayer=l,{transaction:m,connection:u}},createBridgeTransactionFromRelayQuote:async({quote:t,from:n,cluster:c})=>{let l=t.steps[0]?.items?.[0];if(!l)return;let m=l.data.instructions.map((({keys:e,programId:t,data:n})=>new r({keys:e.map((({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:new a(e),isSigner:t,isWritable:n}))),programId:new a(t),data:Buffer.from(n,"hex")}))),u=l.data.addressLookupTableAddresses?.map((e=>new a(e))),p=new e(i(c)),d=await Promise.all((u??[]).map((async e=>p.getAddressLookupTable(e).then((e=>e.value))))),{blockhash:w}=await p.getLatestBlockhash();return{transaction:new s(new o({payerKey:new a(n),instructions:m,recentBlockhash:w}).compileToV0Message(d)),connection:p}}};export{l as default};
