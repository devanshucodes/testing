import type { PrivyBitcoinSegwitEmbeddedWalletAccount, PrivyBitcoinTaprootEmbeddedWalletAccount, PrivyEthereumEmbeddedWalletAccount, PrivySolanaEmbeddedWalletAccount, PrivyUser } from '@privy-io/public-api/schemas';
import type { Chain } from './chains';
import { EmbeddedSolanaWalletProvider, EmbeddedWalletProvider } from './embedded';
import { EmbeddedBitcoinWalletProvider } from './embedded/EmbeddedBitcoinWalletProvider';
import type { ChainType, EntropyIdVerifier, IEmbeddedWalletRecoveryOptions, PrivyResponseEvent, SetRecoveryInput, SetRecoveryOutput } from './embedded/types';
import type { NonEmptyArray } from './utils/NonEmptyArray';
/** Options for creating the Solana embedded wallet */
type CreateSolanaOpts = {
    /**
     * The user's existing Ethereum embedded wallet if they have one. This parameter
     * MUST be set if the user has an Ethereum embedded wallet, otherwise Solana creation
     * will fail in the iframe.
     */
    ethereumAccount?: PrivyEthereumEmbeddedWalletAccount;
};
export type LoadWalletParams = {
    wallet: PrivyEthereumEmbeddedWalletAccount | PrivySolanaEmbeddedWalletAccount | PrivyBitcoinSegwitEmbeddedWalletAccount | PrivyBitcoinTaprootEmbeddedWalletAccount;
    entropyId: string;
    entropyIdVerifier: EntropyIdVerifier;
    recoveryPassword?: string;
    recoveryAccessToken?: string;
    recoverySecretOverride?: string;
};
export default class EmbeddedWalletApi {
    /**
     * Add a new embedded wallet account.
     *
     * Requires that the user already have created an embedded wallet via `create`.
     *
     * @param o input options
     * @param o.chainType the type of wallet to create
     * @param o.hdWalletIndex the index of the wallet to create
     * @param o.entropyId the key used to look up the existing wallet
     * @param o.entropyIdVerifier the method used to verify the entropy ID
     *
     * @returns the updated user
     */
    add(opts: {
        chainType: ChainType;
        hdWalletIndex: number;
        entropyId: string;
        entropyIdVerifier: EntropyIdVerifier;
    }): Promise<{
        user: {
            id: string;
            mfa_methods: ({
                type: "sms";
                verified_at: number;
            } | {
                type: "totp";
                verified_at: number;
            } | {
                type: "passkey";
                verified_at: number;
            })[];
            linked_accounts: ({
                type: "email";
                address: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
            } | {
                type: "phone";
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                phoneNumber: string;
            } | {
                type: "wallet";
                address: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                chain_type: "ethereum";
                wallet_client: "unknown";
                chain_id?: string | undefined;
                wallet_client_type?: string | undefined;
                connector_type?: string | undefined;
            } | {
                type: "smart_wallet";
                address: string;
                smart_wallet_type: "safe" | "kernel" | "biconomy" | "light_account" | "coinbase_smart_wallet";
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
            } | {
                type: "wallet";
                address: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                chain_type: "solana";
                wallet_client: "unknown";
                wallet_client_type?: string | undefined;
                connector_type?: string | undefined;
            } | {
                type: "farcaster";
                fid: number;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                owner_address: string;
                username?: string | undefined;
                display_name?: string | undefined;
                bio?: string | undefined;
                profile_picture?: string | undefined;
                profile_picture_url?: string | undefined;
                homepage_url?: string | undefined;
                signer_public_key?: string | undefined;
            } | {
                type: "passkey";
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                credential_id: string;
                enrolled_in_mfa: boolean;
                created_with_browser?: string | undefined;
                created_with_os?: string | undefined;
                created_with_device?: string | undefined;
                authenticator_name?: string | undefined;
            } | {
                telegramUserId: string;
                firstName: string | null | undefined;
                type: "telegram";
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                telegram_user_id: string;
                username?: string | null | undefined;
                first_name?: string | null | undefined;
                last_name?: string | null | undefined;
                photo_url?: string | null | undefined;
            } | {
                type: "wallet";
                address: string;
                chain_id: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                chain_type: "ethereum";
                wallet_client: "privy";
                wallet_client_type: "privy";
                connector_type: "embedded";
                imported: boolean;
                delegated: boolean;
                wallet_index: number;
                recovery_method: "user-passcode" | "google-drive" | "icloud" | "privy";
            } | {
                type: "wallet";
                address: string;
                public_key: string;
                chain_id: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                chain_type: "solana";
                wallet_client: "privy";
                wallet_client_type: "privy";
                connector_type: "embedded";
                imported: boolean;
                delegated: boolean;
                wallet_index: number;
                recovery_method: "user-passcode" | "google-drive" | "icloud" | "privy";
            } | {
                type: "wallet";
                address: string;
                public_key: string;
                chain_id: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                chain_type: "bitcoin-segwit";
                wallet_client: "privy";
                wallet_client_type: "privy";
                connector_type: "embedded";
                imported: boolean;
                delegated: boolean;
                wallet_index: number;
                recovery_method: "user-passcode" | "google-drive" | "icloud" | "privy";
            } | {
                type: "wallet";
                address: string;
                public_key: string;
                chain_id: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                chain_type: "bitcoin-taproot";
                wallet_client: "privy";
                wallet_client_type: "privy";
                connector_type: "embedded";
                imported: boolean;
                delegated: boolean;
                wallet_index: number;
                recovery_method: "user-passcode" | "google-drive" | "icloud" | "privy";
            } | {
                type: "google_oauth";
                name: string | null;
                email: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "twitter_oauth";
                name: string | null;
                username: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                profile_picture_url: string | null;
                subject: string;
            } | {
                type: "discord_oauth";
                email: string | null;
                username: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "github_oauth";
                name: string | null;
                email: string | null;
                username: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "linkedin_oauth";
                email: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
                name?: string | undefined;
                vanity_name?: string | undefined;
            } | {
                type: "spotify_oauth";
                name: string | null;
                email: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "instagram_oauth";
                username: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "tiktok_oauth";
                name: string | null;
                username: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "apple_oauth";
                email: string | null;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
            } | {
                type: "custom_auth";
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                custom_user_id: string;
            } | {
                type: "cross_app";
                provider_app_id: string;
                verified_at: number;
                first_verified_at: number | null;
                latest_verified_at: number | null;
                subject: string;
                embedded_wallets: {
                    address: string;
                }[];
                smart_wallets: {
                    address: string;
                }[];
            })[];
            created_at: number;
            has_accepted_terms: boolean;
            is_guest: boolean;
            custom_metadata?: Record<string, string | number | boolean> | undefined;
        };
    }>;
    getBitcoinProvider({ wallet, entropyId, entropyIdVerifier, recoveryPassword, recoveryAccessToken, recoverySecretOverride, }: {
        wallet: PrivyBitcoinSegwitEmbeddedWalletAccount | PrivyBitcoinTaprootEmbeddedWalletAccount;
        entropyId: string;
        entropyIdVerifier: EntropyIdVerifier;
        recoveryPassword?: string;
        recoveryAccessToken?: string;
        recoverySecretOverride?: string;
    }): Promise<EmbeddedBitcoinWalletProvider>;
    /**
     * Creates an embedded wallet
     *
     * @param password Recovery password for the embedded wallet
     * @param recoveryMethod {IEmbeddedWalletRecoveryOptions} recovery method to create the wallet with
     * @param recoveryToken {string} access token for recovery
     * @param recoverySecretOverride {string} override for the recovery secret used to encrypt the recovery shares
     * @param iCloudRecordNameOverride {string} override for the icloud record name where the recovery secret is stored in cloud recovery
     * @param solanaAccount {PrivySolanaEmbeddedWalletAccount} The user's existing Solana embedded wallet if they have one. This parameter
     * MUST be set if the user has an Solana embedded wallet, otherwise Ethereum creation
     * will fail in the iframe.
     * @returns EmbeddedWalletProvider implementing EIP1193Provider
     */
    create(password?: string, recoveryMethod?: IEmbeddedWalletRecoveryOptions, recoveryToken?: string, recoverySecretOverride?: string, iCloudRecordNameOverride?: string, solanaAccount?: PrivySolanaEmbeddedWalletAccount): Promise<{
        user: PrivyUser;
        provider: EmbeddedWalletProvider;
    }>;
    /**
     * Creates an embedded Solana wallet
     *
     * @param opts.ethereumAccount {PrivyEthereumEmbeddedWalletAccount} the user's existing embedded wallet account if they have one. This parameter
     * MUST be passed if the user has an existing Ethereum embedded wallet otherwise Solana wallet creation will fail.
     * @returns EmbeddedWalletProvider implementing Phantom Provider
     */
    createSolana(opts?: CreateSolanaOpts): Promise<{
        user: PrivyUser;
        provider: EmbeddedSolanaWalletProvider;
    }>;
    /**
     * Creates an additional embedded Solana wallet at the specified HD index.
     *
     * @deprecated use privy.embeddedWallet.add instead
     *
     * @param o
     * @param o.primaryWalletAddress The address of this wallet at index 0
     * @param o.hdWalletIndex The index at which to derive a new account
     *
     * @returns A provider that can be used to sign messages with the embedded wallet.
     */
    createAdditionalSolana({ primaryPublicKey, hdWalletIndex, }: {
        primaryPublicKey: string;
        hdWalletIndex: number;
    }): Promise<{
        user: PrivyUser;
        provider: EmbeddedSolanaWalletProvider;
    }>;
    hasEmbeddedWallet(): Promise<boolean>;
    isPasswordRequired(): Promise<boolean>;
    /**
     * Retrieve this users embedded wallet.
     * If the wallet has never been used on this device recover.
     *
     * @param password Recovery password for the embedded wallet
     * @returns EmbeddedWalletProvider implementing EIP1193Provider
     */
    getProvider(wallet: PrivyEthereumEmbeddedWalletAccount, recoveryPassword?: string, recoveryAccessToken?: string, recoverySecretOverride?: string): Promise<EmbeddedWalletProvider>;
    /**
     * Retrieve this users embedded Solana wallet.
     * If the wallet has never been used on this device recover.
     *
     * @returns EmbeddedSolanaWalletProvider
     */
    getSolanaProvider(account: PrivySolanaEmbeddedWalletAccount, entropyId: string, entropyIdVerifier: EntropyIdVerifier, recoveryPassword?: string, recoveryAccessToken?: string, recoverySecretOverride?: string): Promise<EmbeddedSolanaWalletProvider>;
    /**
     * @deprecated Use `setRecovery` instead.
     *
     * Add or change the password used to recover an embedded wallet.
     *
     * @param password New recovery password
     * @param currentPassword Current recovery password used to recover the embedded wallet
     * @returns EmbeddedWalletProvider implementing EIP1193Provider
     */
    setPassword(wallet: PrivyEthereumEmbeddedWalletAccount, password: string): Promise<EmbeddedWalletProvider>;
    /**
     * Add or change the recovery method used to recover an embedded wallet.
     *
     * @param password New recovery password
     * @param currentPassword Current recovery password used to recover the embedded wallet
     * @returns PrivyUser the user object with the updated embedded wallet.
     * @returns EmbeddedWalletProvider implementing EIP1193Provider if the input wallet is an Ethereum wallet.
     */
    setRecovery(setRecoveryInput: SetRecoveryInput): Promise<SetRecoveryOutput>;
    /**
     * @returns URL to load in the embedded wallet iframe
     */
    getURL(): string;
    /**
     * @deprecated Require higher level SDKs to pass in the chain configuration
     */
    get chains(): NonEmptyArray<Chain>;
    /**
     * @deprecated Use `onMessage` instead
     *
     * @returns Allows the user to subscribe
     * to the response events from the embedded wallet iframe
     *
     * @example
     * const handler = privy.wallet.getMessageHandler()
     * window.addEventListener('message', handler)
     */
    getMessageHandler(): (event: PrivyResponseEvent) => void;
    /**
     * Handles messages from the embedded wallet secure contexts
     *
     * @example
     * const onMessage = async (e: WebViewMessageEvent) => {
     *   const {data} = e.nativeEvent;
     *   client.embeddedWallet.onMessage(JSON.parse(data));
     * }
     */
    onMessage(event: PrivyResponseEvent): void;
}
export {};
