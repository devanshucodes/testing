/**
 * We support a subset of the provider methods found here:
 *
 *     https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods
 *
 * For now, we're focused on signing-related methods because the iframe (this code)
 * is the only place that has access to the private key and thus is the only one
 * who can create signatures. All other methods do not need the private key and
 * can therefore be implemented by clients of the iframe.
 */
import type { TypedMessage, MessageTypes } from '@metamask/eth-sig-util';
import type { PrivyEthereumEmbeddedWalletAccount, PrivySolanaEmbeddedWalletAccount, PrivyUser } from '@privy-io/public-api';
import type { EmbeddedWalletProvider } from './EmbeddedWalletProvider';
import type { MfaSubmitArgs } from './withMfa';
export declare const SUPPORTED_JSON_RPC_METHODS: readonly ["eth_sign", "eth_populateTransactionRequest", "eth_signTransaction", "personal_sign", "eth_signTypedData_v4"];
export type JsonRpcMethodType = (typeof SUPPORTED_JSON_RPC_METHODS)[number];
export declare const isSupportedRpcMethod: (method: any) => method is JsonRpcMethodType;
export type Quantity = string | number | bigint;
export type UnsignedTransactionRequest = {
    from?: string;
    to?: string;
    nonce?: Quantity;
    gasLimit?: Quantity;
    gasPrice?: Quantity;
    data?: ArrayLike<number> | string;
    value?: Quantity;
    chainId?: number;
    type?: number;
    accessList?: Array<{
        address: string;
        storageKeys: Array<string>;
    }> | Array<[string, Array<string>]> | Record<string, Array<string>>;
    maxPriorityFeePerGas?: Quantity;
    maxFeePerGas?: Quantity;
};
/**
 * {@link UnsignedTransactionRequest} specifies the `chainId` field as optional,
 * which matches ethers, wagmi, and a bunch of other libraries.
 *
 * However, we need the transaction's `chainId` to ensure it does price conversion, quote
 * labeling, etc. importantly.
 *
 * > Note:
 * > If the developer does not set a `chainId` in their `UnsignedTransactionRequest`,
 * > we default to the embedded provider's  current `chainId`
 */
export type UnsignedTransactionRequestWithChainId = UnsignedTransactionRequest & {
    chainId: number;
};
export type TransactionLog = {
    blockNumber: number;
    blockHash: string;
    transactionIndex: number;
    removed: boolean;
    address: string;
    data: string;
    topics: Array<string>;
    transactionHash: string;
    logIndex: number;
};
export type TransactionReceipt = {
    to: string;
    from: string;
    contractAddress: string;
    transactionIndex: number;
    root?: string;
    logs: Array<TransactionLog>;
    logsBloom: string;
    blockHash: string;
    transactionHash: string;
    blockNumber: number;
    confirmations: number;
    byzantium: boolean;
    type: number;
    status?: number;
    gasUsed: string;
    cumulativeGasUsed: string;
    effectiveGasPrice: string;
};
interface BaseRpcRequestType {
    method: JsonRpcMethodType;
}
interface eth_populateTransactionRequest extends BaseRpcRequestType {
    method: 'eth_populateTransactionRequest';
    params: [UnsignedTransactionRequest];
}
interface eth_populateTransactionRequestResponse {
    method: 'eth_populateTransactionRequest';
    data: UnsignedTransactionRequest;
}
interface eth_signTransaction extends BaseRpcRequestType {
    method: 'eth_signTransaction';
    params: [UnsignedTransactionRequest];
}
interface eth_sign extends BaseRpcRequestType {
    method: 'eth_sign';
    params: [address: string, message: string];
}
interface eth_signResponse {
    method: 'eth_sign';
    data: string;
}
interface personal_sign extends BaseRpcRequestType {
    method: 'personal_sign';
    params: [string, string];
}
interface personal_signResponse {
    method: 'personal_sign';
    data: string;
}
interface eth_signTransactionResponse {
    method: 'eth_signTransaction';
    data: string;
}
interface eth_sendTransaction {
    method: 'eth_sendTransaction';
    data: string;
}
interface eth_signTypedData_v4 extends BaseRpcRequestType {
    method: 'eth_signTypedData_v4';
    params: [string, TypedMessage<MessageTypes> | string];
}
interface eth_signTypedData_v4Response {
    method: 'eth_signTypedData_v4';
    data: string;
}
export type RpcRequestType = eth_sendTransaction | eth_signTransaction | eth_populateTransactionRequest | eth_sign | personal_sign | eth_signTypedData_v4;
export type RpcResponseType = eth_signTransactionResponse | eth_populateTransactionRequestResponse | eth_signResponse | personal_signResponse | eth_signTypedData_v4Response;
export interface SolanaRpcResponseType {
    data: {
        signature: string;
    };
}
declare const SUPPORTED_SOLANA_RPC_METHODS: readonly ["signMessage"];
type SolanaRpcMethodType = (typeof SUPPORTED_SOLANA_RPC_METHODS)[number];
export declare const isSupportedSolanaRpcMethod: (method: any) => method is SolanaRpcMethodType;
export interface BaseSolanaRpcRequestType {
    method: SolanaRpcMethodType;
    params: any;
}
export interface SolanaRpcRequestType extends BaseSolanaRpcRequestType {
    method: 'signMessage';
    params: {
        message: string;
    };
}
export type BaseBitcoinRpcRequestType = {
    method: string;
    params: any;
};
export type BaseBitcoinRpcResponseType = {
    method: string;
    data: any;
};
/**
 * Within the Privy SDK(s), the caller of Bitcoin `sign` will pass us the `message`
 * as a `Uint8Array`. Our SDK(s) will then serialize that `Uint8Array` to a utf8 `string`
 * to pass it over the iframe message bus.
 * Thus, our iframe accepts the message as a `string` but must deserialize it back to a `Uint8Array`
 * before computing the signature over it.
 */
export interface bitcoin_sign extends BaseBitcoinRpcRequestType {
    method: 'sign';
    params: {
        message: string;
    };
}
/**
 * The Privy SDK(s) will return the signature as a `Uint8Array`, but the iframe must serialize it to
 * a `string` in order to pass it over the message bus. You can see how this is done in the signature handler.
 *
 * The Privy SDK(s) themselves must then deserialize the `string` to a `Uint8Array` before
 * returning the signature to the caller.
 */
export interface bitcoin_signResponse extends BaseBitcoinRpcResponseType {
    method: 'sign';
    data: {
        signature: string;
    };
}
/**
 * RPC method for signing a transaction.
 *
 * The iframe expects a Partially Signed Bitcoin Transaction or PSBT, for short. We
 * will parse the hex-endoed input to a Transaction object and sign it with the private
 * key, returning the signed transaction hash, rather than just a signature.
 *
 * ref: https://github.com/bitcoin/bitcoin/blob/master/doc/psbt.md
 */
export interface bitcoin_signTransaction extends BaseBitcoinRpcRequestType {
    method: 'signTransaction';
    params: {
        psbt: string;
    };
}
export interface bitcoin_signTransactionResponse extends BaseBitcoinRpcResponseType {
    method: 'signTransaction';
    data: {
        signedTransaction: string;
    };
}
export type BitcoinRpcRequestType = bitcoin_sign | bitcoin_signTransaction;
export type BitcoinRpcResponseType = bitcoin_signResponse | bitcoin_signTransactionResponse;
export type PrivyEventType = 'privy:iframe:ready' | 'privy:wallets:create' | 'privy:wallets:add' | 'privy:wallets:set-recovery' | 'privy:wallets:connect' | 'privy:wallets:recover' | 'privy:wallets:rpc' | 'privy:wallet:create' | 'privy:wallet:connect' | 'privy:wallet:recover' | 'privy:wallet:rpc' | 'privy:solana-wallet:create' | 'privy:solana-wallet:create-additional' | 'privy:solana-wallet:connect' | 'privy:solana-wallet:recover' | 'privy:solana-wallet:rpc' | 'privy:mfa:verify' | 'privy:mfa:init-enrollment' | 'privy:mfa:submit-enrollment' | 'privy:mfa:unenroll' | 'privy:mfa:clear';
export type IEmbeddedWalletRecoveryOptions = 'privy' | 'user-passcode' | 'google-drive' | 'icloud' | 'icloud-native';
export type IUserRecoveryMethod = 'user-passcode' | 'google-drive' | 'icloud' | 'icloud-native';
export type EmbeddedWalletRecoveryOptions = 'privy' | 'user-passcode' | 'google-drive' | 'icloud';
export type PasswordRecoveryInput = {
    recoveryMethod: 'user-passcode';
    password: string;
};
export type CloudRecoveryInput = {
    recoveryMethod: 'google-drive' | 'icloud';
    recoveryAccessToken: string;
};
export type ICloudNativeRecoveryInput = {
    recoveryMethod: 'icloud-native';
    recoverySecretOverride: string;
    iCloudRecordNameOverride: string;
};
export type SetRecoveryInput = {
    wallet: PrivyEthereumEmbeddedWalletAccount | PrivySolanaEmbeddedWalletAccount;
} & (PasswordRecoveryInput | CloudRecoveryInput | ICloudNativeRecoveryInput);
export interface SetRecoveryOutput {
    /** User object with the updated embedded wallet */
    user: PrivyUser;
    /**
     * Provider for the embedded ethereum wallet.
     *
     * This value will be `null` if and only if the wallet passed in the input is not an Ethereum wallet.
     * @deprecated Get the provider instance from the `getProvider(...)` method instead.
     */
    provider: EmbeddedWalletProvider | null;
}
type BaseProxyRequest = {
    accessToken: string;
} & Partial<MfaSubmitArgs>;
type PrivyResponseBaseEventType<E extends PrivyEventType, D extends PrivyResponseDataType> = {
    id: string;
    event: E;
    data: D;
};
type PrivyEventResponseCallbacksType<R extends PrivyResponseDataType> = {
    reject: (error: Error) => void;
    resolve: (res: R) => void;
};
export type ChainType = 'ethereum' | 'solana' | 'bitcoin-taproot' | 'bitcoin-segwit';
type BaseWalletsRequestData = BaseProxyRequest;
export type IframeReadyRequestDataType = Record<string, never>;
export type IframeReadyResponseDataType = Record<string, never>;
export type IframeReadyResponseCallbacksType = PrivyEventResponseCallbacksType<IframeReadyResponseDataType>;
type IframeReadyResponseEventType = PrivyResponseBaseEventType<'privy:iframe:ready', IframeReadyResponseDataType>;
export type WalletsCreateRequestDataType = BaseWalletsRequestData & {
    /** Optional: the user-specified recovery password, replaces recoveryPin */
    recoveryPassword?: string;
    /** Optional: the recovery method to be used for the created wallet */
    recoveryMethod?: EmbeddedWalletRecoveryOptions;
    /** Optional: in the case of cloud recovery, the access token to be used to communicated with the cloud provider (eg Google) */
    recoveryAccessToken?: string;
    /** Optional: override the recoverySecret, only for use when we need to store recovery secrets in cloud storage outside of the iframe (eg native) */
    recoverySecretOverride?: string;
    /** Optional: override the iCloudRecordName, only for use when we need to store recovery secrets in cloud storage outside of the iframe (eg native) */
    iCloudRecordNameOverride?: string;
};
export type WalletsCreateResponseDataType = {
    address: string;
};
export type WalletsCreateResponseCallbacksType = PrivyEventResponseCallbacksType<WalletsCreateResponseDataType>;
type WalletsCreateResponseEventType = PrivyResponseBaseEventType<'privy:wallets:create', WalletsCreateResponseDataType>;
export type EntropyIdVerifier = 'ethereum-address-verifier' | 'solana-address-verifier';
export type WalletsAddRequestDataType = BaseWalletsRequestData & {
    /**
     * The HD node index at which to create a wallet. Must be >= 1 for ethereum
     * and solana, must be >= 0 otherwise.
     */
    hdWalletIndex: number;
    chainType: ChainType;
    /**
     * Key with which to look up the existing entropy
     */
    entropyId: string;
    /**
     * Source of the `entropyId` property. This field determines how the entropyId will
     * be used. Possible values include:
     * - ethereum-address-verifier: the entropyId is the address of the Ethereum wallet derived
     * at index 0 for this entropy
     * - solana-address-verifier: the entropyId is a the address of the Solana wallet derived
     * at index 0 for this entropy
     *
     * When this field is a wallet address, we can verify reconstitution was successful by
     * deriving the specified wallet and comparing the address to the `entropyId`
     */
    entropyIdVerifier: EntropyIdVerifier;
};
export type WalletsAddResponseDataType = {
    address: string;
};
export type WalletsAddResponseCallbacksType = PrivyEventResponseCallbacksType<WalletsAddResponseDataType>;
type WalletsAddResponseEventType = PrivyResponseBaseEventType<'privy:wallets:add', WalletsAddResponseDataType>;
type WalletsSetRecoveryBaseRequestDataType = BaseWalletsRequestData & {
    /**
     * Key with which to look up the existing entropy
     */
    entropyId: string;
    /**
     * Source of the `entropyId` property. This field determines how the entropyId will
     * be used. Possible values include:
     * - ethereum-address-verifier: the entropyId is the address of the Ethereum wallet derived
     * at index 0 for this entropy
     * - solana-address-verifier: the entropyId is a the address of the Solana wallet derived
     * at index 0 for this entropy
     *
     * When this field is a wallet address, we can verify reconstitution was successful by
     * deriving the specified wallet and comparing the address to the `entropyId`
     */
    entropyIdVerifier: EntropyIdVerifier;
    existingRecoveryMethod?: EmbeddedWalletRecoveryOptions;
};
type WalletsSetRecoveryPasswordDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'user-passcode';
    recoveryPassword: string;
};
type WalletsSetRecoveryGoogleDriveDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'google-drive';
    recoveryAccessToken: string;
};
type WalletsSetRecoveryICloudDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'icloud';
    recoveryAccessToken: string;
};
type WalletsSetRecoveryICloudNativeDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'icloud-native';
    recoverySecretOverride: string;
    iCloudRecordNameOverride: string;
};
export type WalletsSetRecoveryRequestDataType = Omit<WalletsSetRecoveryPasswordDataType, 'chainType'> | Omit<WalletsSetRecoveryGoogleDriveDataType, 'chainType'> | Omit<WalletsSetRecoveryICloudDataType, 'chainType'> | Omit<WalletsSetRecoveryICloudNativeDataType, 'chainType'>;
export type RecoveryOnlyWalletsSetRecoveryRequestDataType = Omit<WalletsSetRecoveryPasswordDataType, keyof WalletsSetRecoveryBaseRequestDataType> | Omit<WalletsSetRecoveryGoogleDriveDataType, keyof WalletsSetRecoveryBaseRequestDataType> | Omit<WalletsSetRecoveryICloudDataType, keyof WalletsSetRecoveryBaseRequestDataType> | Omit<WalletsSetRecoveryICloudNativeDataType, keyof WalletsSetRecoveryBaseRequestDataType>;
export type WalletsSetRecoveryResponseDataType = {
    entropyId: string;
    entropyIdVerifier: EntropyIdVerifier;
    recoveryMethod: WalletsSetRecoveryRequestDataType['recoveryMethod'];
};
export type WalletsSetRecoveryResponseCallbacksType = PrivyEventResponseCallbacksType<WalletsSetRecoveryResponseDataType>;
type WalletsSetRecoveryResponseEventType = PrivyResponseBaseEventType<'privy:wallets:set-recovery', WalletsSetRecoveryResponseDataType>;
export type WalletsConnectRequestDataType = BaseProxyRequest & {
    /**
     * Key with which to look up the existing entropy
     */
    entropyId: string;
    /**
     * Source of the `entropyId` property. This field determines how the entropyId will
     * be used. Possible values include:
     * - ethereum-address-verifier: the entropyId is the address of the Ethereum wallet derived
     * at index 0 for this entropy
     * - solana-address-verifier: the entropyId is a the address of the Solana wallet derived
     * at index 0 for this entropy
     *
     * When this field is a wallet address, we can verify reconstitution was successful by
     * deriving the specified wallet and comparing the address to the `entropyId`
     */
    entropyIdVerifier: EntropyIdVerifier;
};
export type WalletsConnectResponseDataType = {
    entropyId: string;
};
export type WalletsConnectResponseCallbacksType = PrivyEventResponseCallbacksType<WalletsConnectResponseDataType>;
type WalletsConnectResponseEventType = PrivyResponseBaseEventType<'privy:wallets:connect', WalletsConnectResponseDataType>;
export type WalletsRecoverRequestDataType = BaseProxyRequest & {
    /**
     * Key with which to look up the existing entropy
     */
    entropyId: string;
    /**
     * Source of the `entropyId` property. This field determines how the entropyId will
     * be used. Possible values include:
     * - ethereum-address-verifier: the entropyId is the address of the Ethereum wallet derived
     * at index 0 for this entropy
     * - solana-address-verifier: the entropyId is a the address of the Solana wallet derived
     * at index 0 for this entropy
     *
     * When this field is a wallet address, we can verify reconstitution was successful by
     * deriving the specified wallet and comparing the address to the `entropyId`
     */
    entropyIdVerifier: EntropyIdVerifier;
    /** Optional: the user-specified recovery password, replaces recoveryPin */
    recoveryPassword?: string;
    /** Optional: in the case of cloud recovery, the access token to be used to communicated with the cloud provider (eg Google) */
    recoveryAccessToken?: string;
    /** Optional: override the recoverySecret, only for use when we need to retrieve recovery secrets in cloud storage outside of the iframe (eg native) */
    recoverySecretOverride?: string;
};
export type WalletsRecoverResponseDataType = {
    entropyId: string;
};
export type WalletsRecoverResponseCallbacksType = PrivyEventResponseCallbacksType<WalletsRecoverResponseDataType>;
type WalletsRecoverResponseEventType = PrivyResponseBaseEventType<'privy:wallets:recover', WalletsRecoverResponseDataType>;
type WalletsRpcEthereumRequestDataType = {
    chainType: 'ethereum';
    request: RpcRequestType;
};
type WalletsRpcSolanaRequestDataType = {
    chainType: 'solana';
    request: SolanaRpcRequestType;
};
type WalletsRpcBitcoinRequestDataType = {
    chainType: 'bitcoin-taproot' | 'bitcoin-segwit';
    request: BitcoinRpcRequestType;
};
export type WalletsRpcRequestDataType = BaseWalletsRequestData & {
    /**
     * Key with which to look up the existing entropy
     */
    entropyId: string;
    /**
     * Source of the `entropyId` property. This field determines how the entropyId will
     * be used. Possible values include:
     * - ethereum-address-verifier: the entropyId is the address of the Ethereum wallet derived
     * at index 0 for this entropy
     * - solana-address-verifier: the entropyId is a the address of the Solana wallet derived
     * at index 0 for this entropy
     *
     * When this field is a wallet address, we can verify reconstitution was successful by
     * deriving the specified wallet and comparing the address to the `entropyId`
     */
    entropyIdVerifier: EntropyIdVerifier;
    /**
     * The HD node index at which to create a wallet.
     *
     * Must be >= 1 AND equal to the next index in the sequence.j
     */
    hdWalletIndex: number;
    chainType: ChainType;
} & (WalletsRpcEthereumRequestDataType | WalletsRpcSolanaRequestDataType | WalletsRpcBitcoinRequestDataType);
type WalletsRpcEthereumResponseDataType = {
    chainType: 'ethereum';
    response: RpcResponseType;
};
type WalletsRpcSolanaResponseDataType = {
    chainType: 'solana';
    response: SolanaRpcResponseType;
};
type WalletsRpcBitcoinResponseDataType = {
    chainType: 'bitcoin-taproot' | 'bitcoin-segwit';
    response: BitcoinRpcResponseType;
};
export type WalletsRpcResponseDataType = {
    address: string;
} & (WalletsRpcEthereumResponseDataType | WalletsRpcSolanaResponseDataType | WalletsRpcBitcoinResponseDataType);
export type WalletsRpcResponseCallbacksType = PrivyEventResponseCallbacksType<WalletsRpcResponseDataType>;
type WalletsRpcResponseEventType = PrivyResponseBaseEventType<'privy:wallets:rpc', WalletsRpcResponseDataType>;
export type EthereumWalletCreateRequestDataType = BaseProxyRequest & {
    accessToken: string;
    recoveryPassword?: string;
    recoveryMethod?: IEmbeddedWalletRecoveryOptions;
    recoveryAccessToken?: string;
    recoverySecretOverride?: string;
    iCloudRecordNameOverride?: string;
    /**
     * The user's existing Solana embedded wallet address if they have one. This parameter must be passed
     * if the user has an Solana embedded wallet, otherwise Ethereum wallet creation will fail.
     */
    solanaAddress?: string;
};
export type WalletCreateRequestDataType = EthereumWalletCreateRequestDataType;
export type WalletCreateResponseDataType = {
    address: string;
};
export type WalletCreateResponseCallbacksType = PrivyEventResponseCallbacksType<WalletCreateResponseDataType>;
type WalletCreateResponseEventType = PrivyResponseBaseEventType<'privy:wallet:create', WalletCreateResponseDataType>;
export type WalletConnectRequestDataType = BaseProxyRequest & {
    address: string;
};
export type WalletConnectResponseDataType = {
    address: string;
};
export type WalletConnectResponseCallbacksType = PrivyEventResponseCallbacksType<WalletConnectResponseDataType>;
type WalletConnectResponseEventType = PrivyResponseBaseEventType<'privy:wallet:connect', WalletConnectResponseDataType>;
export type WalletRecoverRequestDataType = BaseProxyRequest & {
    address: string;
    recoveryPassword?: string;
    recoveryMethod?: string;
    recoveryAccessToken?: string;
    recoverySecretOverride?: string;
};
export type WalletRecoverResponseDataType = {
    address: string;
};
export type WalletRecoverResponseCallbacksType = PrivyEventResponseCallbacksType<WalletRecoverResponseDataType>;
type WalletRecoverResponseEventType = PrivyResponseBaseEventType<'privy:wallet:recover', WalletRecoverResponseDataType>;
export type WalletRpcRequestDataType = BaseProxyRequest & {
    address: string;
    request: RpcRequestType;
};
export type WalletRpcResponseDataType = {
    address: string;
    response: RpcResponseType;
};
export type WalletRpcResponseCallbacksType = PrivyEventResponseCallbacksType<WalletRpcResponseDataType>;
type WalletRpcResponseEventType = PrivyResponseBaseEventType<'privy:wallet:rpc', WalletRpcResponseDataType>;
export type SolanaWalletCreateRequestDataType = BaseProxyRequest & {
    /**
     * The user's existing Ethereum embedded wallet address if they have one. This parameter must be passed
     * if the user has an Ethereum embedded wallet, otherwise Solana wallet creation will fail.
     */
    ethereumAddress?: string;
};
export type SolanaWalletCreateResponseDataType = {
    publicKey: string;
};
export type SolanaWalletCreateResponseCallbacksType = PrivyEventResponseCallbacksType<SolanaWalletCreateResponseDataType>;
type SolanaWalletCreateResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:create', SolanaWalletCreateResponseDataType>;
export type SolanaWalletCreateAdditionalRequestDataType = BaseProxyRequest & {
    /**
     * The address/public key of the solana HD wallet at index 0
     */
    primaryPublicKey: string;
    /**
     * The HD node index at which to create a wallet.
     *
     * Must be >= 1 AND equal to the next index in the sequence.j
     */
    hdWalletIndex: number;
};
export type SolanaWalletCreateAdditionalResponseDataType = {
    publicKey: string;
};
export type SolanaWalletCreateAdditionalResponseCallbacksType = PrivyEventResponseCallbacksType<SolanaWalletCreateAdditionalResponseDataType>;
type SolanaWalletCreateAdditionalResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:create-additional', SolanaWalletCreateAdditionalResponseDataType>;
export type SolanaWalletConnectRequestDataType = BaseProxyRequest & {
    publicKey: string;
};
export type SolanaWalletConnectResponseDataType = {
    publicKey: string;
};
export type SolanaWalletConnectResponseCallbacksType = PrivyEventResponseCallbacksType<SolanaWalletConnectResponseDataType>;
type SolanaWalletConnectResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:connect', SolanaWalletConnectResponseDataType>;
export type SolanaWalletRecoverRequestDataType = BaseProxyRequest & {
    publicKey: string;
};
export type SolanaWalletRecoverResponseDataType = {
    publicKey: string;
};
export type SolanaWalletRecoverResponseCallbacksType = PrivyEventResponseCallbacksType<SolanaWalletRecoverResponseDataType>;
type SolanaWalletRecoverResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:recover', SolanaWalletRecoverResponseDataType>;
export type SolanaWalletRpcRequestDataType = BaseProxyRequest & {
    /**
     * The primary public key of the embedded wallet at HD index 0.
     */
    publicKey: string;
    /**
     * The public key of the signing embedded wallet, which may not be at HD index 0.
     * This is used in the iframe to verify that the correct wallet was derived for
     * signing and defaults to the `publicKey` (HD index 0) if not passed in by the SDK.
     *
     * If an `hdWalletIndex` that is not 0 is passed, this parameter MUST also be passed
     * otherwise the iframe will reject the request.
     */
    signingPublicKey?: string;
    /**
     * The HD wallet index of the signing embedded wallet. This is used by the iframe
     * to derive the correct wallet from the root entropy.
     *
     * If an `hdWalletIndex` that is not 0 is passed, `signingPublicKey` MUST also be
     * passed otherwise the iframe will reject the request.
     */
    hdWalletIndex?: number;
    request: SolanaRpcRequestType;
};
export type SolanaWalletRpcResponseDataType = {
    publicKey: string;
    response: SolanaRpcResponseType;
};
export type SolanaWalletRpcResponseCallbacksType = PrivyEventResponseCallbacksType<SolanaWalletRpcResponseDataType>;
type SolanaWalletRpcResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:rpc', SolanaWalletRpcResponseDataType>;
export type MfaVerifyRequestDataType = BaseProxyRequest;
export type MfaVerifyResponseDataType = Record<string, never>;
export type MfaVerifyResponseCallbacksType = PrivyEventResponseCallbacksType<MfaVerifyResponseDataType>;
type MfaVerifyResponseEventType = PrivyResponseBaseEventType<'privy:mfa:verify', MfaVerifyResponseDataType>;
export type MfaInitEnrollmentRequestDataType = BaseProxyRequest & ({
    method: 'sms';
    phoneNumber: string;
} | {
    method: 'totp';
});
export type MfaInitEnrollmentResponseDataType = {
    method: string;
    secret?: string;
    authUrl?: string;
};
export type MfaInitEnrollmentResponseCallbacksType = PrivyEventResponseCallbacksType<MfaInitEnrollmentResponseDataType>;
type MfaInitEnrollmentResponseEventType = PrivyResponseBaseEventType<'privy:mfa:init-enrollment', MfaInitEnrollmentResponseDataType>;
export type MfaSubmitEnrollmentRequestDataType = BaseProxyRequest & ({
    method: 'sms';
    code: string;
    phoneNumber: string;
} | {
    method: 'totp';
    code: string;
} | {
    method: 'passkey';
    credentialIds: string[];
});
export type MfaSubmitEnrollmentResponseDataType = Record<string, never>;
export type MfaSubmitEnrollmentResponseCallbacksType = PrivyEventResponseCallbacksType<MfaSubmitEnrollmentResponseDataType>;
type MfaSubmitEnrollmentResponseEventType = PrivyResponseBaseEventType<'privy:mfa:submit-enrollment', MfaSubmitEnrollmentResponseDataType>;
export type MfaUnenrollRequestDataType = BaseProxyRequest & {
    method: 'sms' | 'totp';
};
export type MfaUnenrollResponseDataType = Record<string, never>;
export type MfaUnenrollResponseCallbacksType = PrivyEventResponseCallbacksType<MfaUnenrollResponseDataType>;
type MfaUnenrollResponseEventType = PrivyResponseBaseEventType<'privy:mfa:unenroll', MfaUnenrollResponseDataType>;
export type MfaClearRequestDataType = {
    userId: string;
};
export type MfaClearResponseDataType = Record<string, never>;
export type MfaClearResponseCallbacksType = PrivyEventResponseCallbacksType<MfaClearResponseDataType>;
type MfaClearResponseEventType = PrivyResponseBaseEventType<'privy:mfa:clear', MfaClearResponseDataType>;
export type PrivyRequestDataType = IframeReadyRequestDataType | WalletsCreateRequestDataType | WalletsAddRequestDataType | WalletsSetRecoveryRequestDataType | WalletsConnectRequestDataType | WalletsRecoverRequestDataType | WalletsRpcRequestDataType | EthereumWalletCreateRequestDataType | WalletConnectRequestDataType | WalletRecoverRequestDataType | WalletRpcRequestDataType | SolanaWalletCreateRequestDataType | SolanaWalletCreateAdditionalRequestDataType | SolanaWalletRecoverRequestDataType | SolanaWalletConnectRequestDataType | SolanaWalletRpcRequestDataType | MfaVerifyRequestDataType | MfaInitEnrollmentRequestDataType | MfaSubmitEnrollmentRequestDataType | MfaUnenrollRequestDataType | MfaClearRequestDataType;
export type PrivyErrorResponseDataType = {
    error: Error;
};
export type PrivyResponseDataType = IframeReadyResponseDataType | WalletsCreateResponseDataType | WalletsAddResponseDataType | WalletsSetRecoveryResponseDataType | WalletsConnectResponseDataType | WalletsRecoverResponseDataType | WalletsRpcResponseDataType | WalletCreateResponseDataType | WalletConnectResponseDataType | WalletRecoverResponseDataType | WalletRpcResponseDataType | SolanaWalletCreateResponseDataType | SolanaWalletConnectResponseDataType | SolanaWalletRecoverResponseDataType | SolanaWalletRpcResponseDataType | MfaVerifyResponseDataType | MfaInitEnrollmentResponseDataType | MfaSubmitEnrollmentResponseDataType | MfaUnenrollResponseDataType | MfaClearResponseDataType;
export declare const PrivyIframeErrorTypes: readonly ["error", "invalid_request_arguments", "wallet_not_on_device", "invalid_recovery_pin", "insufficient_funds", "mfa_timeout", "missing_or_invalid_mfa", "mfa_verification_max_attempts_reached"];
export type PrivyIframeErrorTypesType = (typeof PrivyIframeErrorTypes)[number];
export type PrivyErrorResponseEventType = PrivyResponseBaseEventType<PrivyEventType, PrivyResponseDataType> & {
    error: {
        type: PrivyIframeErrorTypesType;
        message: string;
    };
};
export type PrivyResponseEvent = IframeReadyResponseEventType | PrivyErrorResponseEventType | WalletsCreateResponseEventType | WalletsAddResponseEventType | WalletsSetRecoveryResponseEventType | WalletsConnectResponseEventType | WalletsRecoverResponseEventType | WalletsRpcResponseEventType | WalletCreateResponseEventType | WalletConnectResponseEventType | WalletRecoverResponseEventType | WalletRpcResponseEventType | SolanaWalletCreateResponseEventType | SolanaWalletCreateAdditionalResponseEventType | SolanaWalletConnectResponseEventType | SolanaWalletRecoverResponseEventType | SolanaWalletRpcResponseEventType | MfaVerifyResponseEventType | MfaInitEnrollmentResponseEventType | MfaSubmitEnrollmentResponseEventType | MfaUnenrollResponseEventType | MfaClearResponseEventType;
export type PrivyResponseCallbacksType = IframeReadyResponseCallbacksType | WalletsCreateResponseCallbacksType | WalletsAddResponseCallbacksType | WalletsSetRecoveryResponseCallbacksType | WalletsConnectResponseCallbacksType | WalletsRecoverResponseCallbacksType | WalletsRpcResponseCallbacksType | WalletCreateResponseCallbacksType | WalletConnectResponseCallbacksType | WalletRecoverResponseCallbacksType | WalletRpcResponseCallbacksType | SolanaWalletCreateResponseCallbacksType | SolanaWalletCreateAdditionalResponseCallbacksType | SolanaWalletConnectResponseCallbacksType | SolanaWalletRecoverResponseCallbacksType | SolanaWalletRpcResponseCallbacksType | MfaVerifyResponseCallbacksType | MfaInitEnrollmentResponseCallbacksType | MfaSubmitEnrollmentResponseCallbacksType | MfaUnenrollResponseCallbacksType | MfaClearResponseCallbacksType;
export type EmbeddedWalletMessagePoster = {
    postMessage: (message: any, targetOrigin: string, transfer?: Transferable) => void;
};
export type PreparedTransactionRequestEIP1559 = UnsignedTransactionRequest & {
    from: string;
    to: string;
    nonce: Quantity;
    chainId: number;
    gasLimit: Quantity;
    type: 2;
    maxFeePerGas: Quantity;
};
export type PreparedTransactionRequestLegacy = UnsignedTransactionRequest & {
    from: string;
    to: string;
    nonce: Quantity;
    chainId: number;
    gasLimit: Quantity;
    type: 0 | 1;
    gasPrice: Quantity;
};
export type PreparedTransactionRequest = PreparedTransactionRequestEIP1559 | PreparedTransactionRequestLegacy;
export {};
