import type { PasskeyAuthenticateInputType } from '@privy-io/public-api';
import type { PrivyClientError } from '../Error';
import { PrivyIframeError } from './errors';
export type MfaMethod = 'sms' | 'totp' | 'passkey';
export type MfaSubmitArgs = {
    mfaMethod: MfaMethod;
    mfaCode: string | PasskeyAuthenticateInputType['authenticator_response'];
    relyingParty: string;
};
export type MfaPromise = {
    current: {
        resolve: (args: MfaSubmitArgs) => void;
        reject: (error: PrivyClientError) => void;
    } | null;
};
export type MfaSubmitPromise = {
    current: {
        resolve: (x: undefined) => void;
        reject: (error: PrivyIframeError) => void;
    } | null;
};
/**
 * Wraps an arbitraru function and signals when it fails due to MFA. Automatically
 * retrying the function when MFA succeeds.
 *
 * This handles the MFA flow, including:
 * - retries
 * - MFA callback prompt
 * - submitions and outer promise resolution.
 */
export declare function withMfa<T>(
/**
 * Function to wrap wit MFA logic
 */
callback: (args?: MfaSubmitArgs) => Promise<T>, 
/**
 * Root promise that blocks until MFA is complete
 */
mfaPromise: MfaPromise, 
/**
 * Promise that blocks upon MFA submit until the iFrame has responded
 */
mfaSubmitPromise: MfaSubmitPromise, 
/**
 * Callback to inform the caller that MFA is required.
 */
onMfaRequired: () => void, 
/**
 * Whether or not to always prompt MFA first, rather than wait for a failing response
 */
mfaAlwaysRequired: boolean | undefined, 
/**
 * Maximum number of retries before failing the operation
 */
maxRetries: number, 
/**
 * Timeout for the MFA attempt
 */
attemptTimeoutMs: number): Promise<Awaited<T>>;
