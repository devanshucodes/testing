import{B as e,g as a,s as t,i as s,I as r,d as n,c as o,a as c,e as d,H as i,b as l}from"./smart-wallets-Dnec2CHA.js";import"permissionless";import"viem";import"@privy-io/public-api";class u extends e{constructor({callbackSelector:e,cause:t,data:s,extraData:r,sender:n,urls:o}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map((e=>`    ${a(e)}`))],`  Sender: ${n}`,`  Data: ${s}`,`  Callback selector: ${e}`,`  Extra data: ${r}`].flat(),name:"OffchainLookupError"})}}class p extends e{constructor({result:e,url:s}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${a(s)}`,`Response: ${t(e)}`],name:"OffchainLookupResponseMalformedError"})}}class f extends e{constructor({sender:e,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${e}`],name:"OffchainLookupSenderMismatchError"})}}const m="0x556f1830",h={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function y(e,{blockNumber:a,blockTag:t,data:i,to:l}){const{args:p}=n({data:i,abi:[h]}),[m,y,b,g,k]=p,{ccipRead:x}=e,O=x&&"function"==typeof x?.request?x.request:w;try{if(!function(e,a){if(!s(e,{strict:!1}))throw new r({address:e});if(!s(a,{strict:!1}))throw new r({address:a});return e.toLowerCase()===a.toLowerCase()}(l,m))throw new f({sender:m,to:l});const n=await O({data:b,sender:m,urls:y}),{data:i}=await o(e,{blockNumber:a,blockTag:t,data:c([g,d([{type:"bytes"},{type:"bytes"}],[n,k])]),to:l});return i}catch(e){throw new u({callbackSelector:g,cause:e,data:i,extraData:k,sender:m,urls:y})}}async function w({data:e,sender:a,urls:s}){let r=new Error("An unknown error occurred.");for(let n=0;n<s.length;n++){const o=s[n],c=o.includes("{data}")?"GET":"POST",d="POST"===c?{data:e,sender:a}:void 0,u="POST"===c?{"Content-Type":"application/json"}:{};try{const s=await fetch(o.replace("{sender}",a).replace("{data}",e),{body:JSON.stringify(d),headers:u,method:c});let n;if(n=s.headers.get("Content-Type")?.startsWith("application/json")?(await s.json()).data:await s.text(),!s.ok){r=new i({body:d,details:n?.error?t(n.error):s.statusText,headers:s.headers,status:s.status,url:o});continue}if(!l(n)){r=new p({result:n,url:o});continue}return n}catch(e){r=new i({body:d,details:e.message,url:o})}}throw r}export{w as ccipRequest,y as offchainLookup,h as offchainLookupAbiItem,m as offchainLookupSignature};
