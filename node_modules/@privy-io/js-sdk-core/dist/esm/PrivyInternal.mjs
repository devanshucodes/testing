import t from"fetch-retry";import{v4 as e}from"uuid";import{PrivyErrorCode as s}from"@privy-io/api-base";import{getPathWithParams as i,AppConfig as a,AnalyticsEvent as n,RefreshSession as r}from"@privy-io/public-api";import{PrivyClientError as o,PrivyApiError as c}from"./Error.mjs";import{Session as h}from"./Session.mjs";import l from"./toAbortSignalTimeout.mjs";import{toSearchParams as d}from"./utils/toSearchParams.mjs";import"eventemitter3";import"jose";import"js-cookie";import"./Token.mjs";import"./utils/allSettled.mjs";const p="privy:caid";class _{baseUrl;_config;appId;appClientId;_storage;_analyticsId;_sdkVersion="js-sdk-core:0.35.5";_fetch;nativeAppIdentifier;callbacks;_cache=new Map;session;constructor(e){this._storage=e.storage,this._analyticsId=null,this._getOrGenerateClientAnalyticsId(),this.baseUrl=e.baseUrl??"https://auth.privy.io",this.appId=e.appId,this.appClientId=e.appClientId,this._sdkVersion=e.sdkVersion??this._sdkVersion,this.callbacks=e.callbacks,this.nativeAppIdentifier=e.nativeAppIdentifier,this.session=new h({storage:this._storage,isUsingServerCookies:!1,appId:e.appId}),this._fetch=t(fetch,{retries:3,retryDelay:500}),this.session.on("error_storing_tokens",(t=>{this.createAnalyticsEvent("error_updating_tokens_in_storage",{reason:t})}))}setCallbacks(t){this.callbacks={...this.callbacks,...t}}get isReady(){return Boolean(this._config)}get config(){return this._config}get caid(){return this._analyticsId}async _initialize(){if(this.isReady)this.callbacks?.setIsReady?.(!0);else{if(!await this.isStorageAccessible())throw new o({code:"storage_error",error:"Unable to access storage"});this._config=await this.getAppConfig(),this._config?.custom_api_url&&(this.baseUrl=this._config.custom_api_url,this.session.isUsingServerCookies=!0),this.callbacks?.setIsReady?.(!0),this.createAnalyticsEvent("sdk_initialize",{})}}async fetch(t,{body:e,params:s,query:a,headers:n,options:r={onRequest:this._beforeRequest.bind(this)}}){const o=`${this.baseUrl}${i(t.path,s)}${d(a)}`,h=new Request(o,{method:t.method,body:JSON.stringify(e),headers:n}),l=await r.onRequest(h),p=await this._fetch(h,l),_=await p.json();if(p.status>299)throw new c(_);return _}async _beforeRequestWithoutInitialize(t){const e=await this.session.getToken(),s=new Headers(t.headers);s.set("privy-app-id",this.appId),this.appClientId&&s.set("privy-client-id",this.appClientId),s.set("privy-client",this._sdkVersion),e&&s.set("Authorization",`Bearer ${e}`),s.set("Content-Type","application/json"),s.set("Accept","application/json");const i=await this._getOrGenerateClientAnalyticsId();return i&&s.set("privy-ca-id",i),this.nativeAppIdentifier&&s.set("x-native-app-identifier",this.nativeAppIdentifier),{signal:l(2e4),headers:s,credentials:"include"}}async beforeRequestWithoutRefresh(t){return await this._initialize(),this._beforeRequestWithoutInitialize(t)}async _beforeRequest(t){return await this._initialize(),await this.getAccessToken(),this.beforeRequestWithoutRefresh(t)}async getAppConfig(){return await this.fetch(a,{params:{app_id:this.appId},options:{onRequest:this._beforeRequestWithoutInitialize.bind(this)}})}async _getOrGenerateClientAnalyticsId(){if(this._analyticsId)return this._analyticsId;try{const t=await this._storage.get(p);if("string"==typeof t&&t.length>0)return this._analyticsId=t,t}catch(t){console.error("Unable to load clientId",t)}try{this._analyticsId=e()}catch(t){console.error("Unable to generate uuidv4",t)}if(!this._analyticsId)return null;try{await this._storage.put(p,this._analyticsId)}catch(t){console.error(`Unable to store clientId: ${this._analyticsId}`,t)}return this._analyticsId}async destroyClientAnalyticsId(){try{return await this._storage.del(p)}catch(t){console.error("Unable to delete clientId",t)}}async createAnalyticsEvent(t,e){try{await this.fetch(n,{body:{event_name:t,client_id:await this._getOrGenerateClientAnalyticsId(),payload:e},options:{onRequest:this.beforeRequestWithoutRefresh.bind(this)}})}catch(t){}}async refreshSession(){const t=await this.session.getRefreshToken()??void 0,e=t??"key",s=this._cache.get(e);if(s)return await s;const i=this._refreshSession(t);this._cache.set(e,i);try{return await i}catch(t){throw t}finally{this._cache.delete(e)}}async _refreshSession(t){const e=await this.session.getToken();if(!this.session.hasRefreshCredentials(e,t??null))throw await this._initialize(),new c({code:s.MISSING_OR_INVALID_TOKEN,error:"No tokens found in storage"});try{const e=await this.fetch(r,{body:{refresh_token:t},options:{onRequest:this.beforeRequestWithoutRefresh.bind(this)}}),s=e.session_update_action;return this.callbacks?.setUser?.(e.user),"set"===s&&await this.session.updateWithTokensResponse(e),"clear"===s&&(await this.session.destroyLocalState(),this.callbacks?.setUser?.(null)),"ignore"===s&&e.token&&(await this.session.storeToken(e.token),e.identity_token&&await this.session.storeIdentityToken(e.identity_token)),e}catch(t){throw t instanceof c&&t.code===s.MISSING_OR_INVALID_TOKEN&&(await this.session.destroyLocalState(),this.callbacks?.setUser?.(null)),t}}async getAccessToken(){const[t,e]=await Promise.all([this.session.getToken(),this.session.getRefreshToken()]);return!this.session.tokenIsActive(t)&&this.session.hasRefreshCredentials(t,e)?(await this.refreshSession(),await this.session.getToken()):t}async getIdentityToken(){return await this.session.getIdentityToken()}async isStorageAccessible(){try{const t="privy:__storage__test",e="blobby";await this._storage.put(t,e);const s=await this._storage.get(t);return await this._storage.del(t),s===e}catch(t){return console.error(t),!1}}}export{_ as PrivyInternal};
